(function(userConfig, defaultConfig) {
    var noop = function() {},
        isEmpty = function(it) {
            for (var p in it) {
                return 0
            }
            return 1
        },
        toString = {}.toString,
        isFunction = function(it) {
            return toString.call(it) == "[object Function]"
        },
        isString = function(it) {
            return toString.call(it) == "[object String]"
        },
        isArray = function(it) {
            return toString.call(it) == "[object Array]"
        },
        forEach = function(vector, callback) {
            if (vector) {
                for (var i = 0; i < vector.length;) {
                    callback(vector[i++])
                }
            }
        },
        mix = function(dest, src) {
            for (var p in src) {
                dest[p] = src[p]
            }
            return dest
        },
        makeError = function(error, info) {
            return mix(new Error(error), {
                src: "dojoLoader",
                info: info
            })
        },
        uidSeed = 1,
        uid = function() {
            return "_" + uidSeed++
        },
        req = function(config, dependencies, callback) {
            return contextRequire(config, dependencies, callback, 0, req)
        },
        global = this,
        doc = global.document,
        element = doc && doc.createElement("DiV"),
        has = req.has = function(name) {
            return isFunction(hasCache[name]) ? hasCache[name] = hasCache[name](global, doc, element) : hasCache[name]
        },
        hasCache = has.cache = defaultConfig.hasCache;
    has.add = function(name, test, now, force) {
        (hasCache[name] === undefined || force) && (hasCache[name] = test);
        return now && has(name)
    };
    0 && has.add("host-node", userConfig.has && "host-node" in userConfig.has ? userConfig.has["host-node"] : typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
    if (0) {
        require("./_base/configNode.js").config(defaultConfig);
        defaultConfig.loaderPatch.nodeRequire = require
    }
    0 && has.add("host-rhino", userConfig.has && "host-rhino" in userConfig.has ? userConfig.has["host-rhino"] : typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object"));
    if (0) {
        for (var baseUrl = userConfig.baseUrl || ".", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;) {
            arg = (rhinoArgs[i++] + "").split("=");
            if (arg[0] == "baseUrl") {
                baseUrl = arg[1];
                break
            }
        }
        load(baseUrl + "/_base/configRhino.js");
        rhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs)
    }
    has.add("host-webworker", typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope);
    if (has("host-webworker")) {
        mix(defaultConfig.hasCache, {
            "host-browser": 0,
            dom: 0,
            "dojo-dom-ready-api": 0,
            "dojo-sniff": 0,
            "dojo-inject-api": 1,
            "host-webworker": 1
        });
        defaultConfig.loaderPatch = {
            injectUrl: function(url, callback) {
                try {
                    importScripts(url);
                    callback()
                } catch (e) {
                    console.info("failed to load resource (" + url + ")");
                    console.error(e)
                }
            }
        }
    }
    for (var p in userConfig.has) {
        has.add(p, userConfig.has[p], 0, 1)
    }
    var requested = 1,
        arrived = 2,
        nonmodule = 3,
        executing = 4,
        executed = 5;
    if (0) {
        requested = "requested";
        arrived = "arrived";
        nonmodule = "not-a-module";
        executing = "executing";
        executed = "executed"
    }
    var legacyMode = 0,
        sync = "sync",
        xd = "xd",
        syncExecStack = [],
        dojoRequirePlugin = 0,
        checkDojoRequirePlugin = noop,
        transformToAmd = noop,
        getXhr;
    if (1) {
        req.isXdUrl = noop;
        req.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_) {
            if (!dojoRequirePlugin) {
                dojoRequirePlugin = dojoRequirePlugin_;
                checkDojoRequirePlugin = checkDojoRequirePlugin_;
                transformToAmd = transformToAmd_
            }
            return {
                sync: sync,
                requested: requested,
                arrived: arrived,
                nonmodule: nonmodule,
                executing: executing,
                executed: executed,
                syncExecStack: syncExecStack,
                modules: modules,
                execQ: execQ,
                getModule: getModule,
                injectModule: injectModule,
                setArrived: setArrived,
                signal: signal,
                finishExec: finishExec,
                execModule: execModule,
                dojoRequirePlugin: dojoRequirePlugin,
                getLegacyMode: function() {
                    return legacyMode
                },
                guardCheckComplete: guardCheckComplete
            }
        };
        if (1 || has("host-webworker")) {
            var locationProtocol = location.protocol,
                locationHost = location.host;
            req.isXdUrl = function(url) {
                if (/^\./.test(url)) {
                    return false
                }
                if (/^\/\//.test(url)) {
                    return true
                }
                var match = url.match(/^([^\/\:]+\:)\/+([^\/]+)/);
                return match && (match[1] != locationProtocol || locationHost && match[2] != locationHost)
            };
            1 || has.add("dojo-xhr-factory", 1);
            has.add("dojo-force-activex-xhr", 1 && !doc.addEventListener && window.location.protocol == "file:");
            has.add("native-xhr", typeof XMLHttpRequest != "undefined");
            if (has("native-xhr") && !has("dojo-force-activex-xhr")) {
                getXhr = function() {
                    return new XMLHttpRequest
                }
            } else {
                for (var XMLHTTP_PROGIDS = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"], progid, i = 0; i < 3;) {
                    try {
                        progid = XMLHTTP_PROGIDS[i++];
                        if (new ActiveXObject(progid)) {
                            break
                        }
                    } catch (e) {}
                }
                getXhr = function() {
                    return new ActiveXObject(progid)
                }
            }
            req.getXhr = getXhr;
            has.add("dojo-gettext-api", 1);
            req.getText = function(url, async, onLoad) {
                var xhr = getXhr();
                xhr.open("GET", fixupUrl(url), false);
                xhr.send(null);
                if (xhr.status == 200 || !location.host && !xhr.status) {
                    if (onLoad) {
                        onLoad(xhr.responseText, async)
                    }
                } else {
                    throw makeError("xhrFailed", xhr.status)
                }
                return xhr.responseText
            }
        }
    } else {
        req.async = 1
    }
    var eval_ = new Function("return eval(arguments[0]);");
    req.eval = function(text, hint) {
        return eval_(text + "\r\n//# sourceURL=" + hint)
    };
    var listenerQueues = {},
        error = "error",
        signal = req.signal = function(type, args) {
            var queue = listenerQueues[type];
            forEach(queue && queue.slice(0), function(listener) {
                listener.apply(null, isArray(args) ? args : [args])
            })
        },
        on = req.on = function(type, listener) {
            var queue = listenerQueues[type] || (listenerQueues[type] = []);
            queue.push(listener);
            return {
                remove: function() {
                    for (var i = 0; i < queue.length; i++) {
                        if (queue[i] === listener) {
                            queue.splice(i, 1);
                            return
                        }
                    }
                }
            }
        };
    var aliases = [],
        paths = {},
        pathsMapProg = [],
        packs = {},
        map = req.map = {},
        mapProgs = [],
        modules = {},
        cacheBust = "",
        cache = {},
        urlKeyPrefix = "url:",
        pendingCacheInsert = {},
        dojoSniffConfig = {},
        insertPointSibling = 0;
    if (1) {
        var consumePendingCacheInsert = function(referenceModule) {
                var p, item, match, now, m;
                for (p in pendingCacheInsert) {
                    item = pendingCacheInsert[p];
                    match = p.match(/^url\:(.+)/);
                    if (match) {
                        cache[urlKeyPrefix + toUrl(match[1], referenceModule)] = item
                    } else if (p == "*now") {
                        now = item
                    } else if (p != "*noref") {
                        m = getModuleInfo(p, referenceModule, true);
                        cache[m.mid] = cache[urlKeyPrefix + m.url] = item
                    }
                }
                if (now) {
                    now(createRequire(referenceModule))
                }
                pendingCacheInsert = {}
            },
            escapeString = function(s) {
                return s.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(c) {
                    return "\\" + c
                })
            },
            computeMapProg = function(map, dest) {
                dest.splice(0, dest.length);
                for (var p in map) {
                    dest.push([p, map[p], new RegExp("^" + escapeString(p) + "(/|$)"), p.length])
                }
                dest.sort(function(lhs, rhs) {
                    return rhs[3] - lhs[3]
                });
                return dest
            },
            computeAliases = function(config, dest) {
                forEach(config, function(pair) {
                    dest.push([isString(pair[0]) ? new RegExp("^" + escapeString(pair[0]) + "$") : pair[0], pair[1]])
                })
            },
            fixupPackageInfo = function(packageInfo) {
                var name = packageInfo.name;
                if (!name) {
                    name = packageInfo;
                    packageInfo = {
                        name: name
                    }
                }
                packageInfo = mix({
                    main: "main"
                }, packageInfo);
                packageInfo.location = packageInfo.location ? packageInfo.location : name;
                if (packageInfo.packageMap) {
                    map[name] = packageInfo.packageMap
                }
                if (!packageInfo.main.indexOf("./")) {
                    packageInfo.main = packageInfo.main.substring(2)
                }
                packs[name] = packageInfo
            },
            delayedModuleConfig = [],
            config = function(config, booting, referenceModule) {
                for (var p in config) {
                    if (p == "waitSeconds") {
                        req.waitms = (config[p] || 0) * 1e3
                    }
                    if (p == "cacheBust") {
                        cacheBust = config[p] ? isString(config[p]) ? config[p] : (new Date).getTime() + "" : ""
                    }
                    if (p == "baseUrl" || p == "combo") {
                        req[p] = config[p]
                    }
                    if (1 && p == "async") {
                        var mode = config[p];
                        req.legacyMode = legacyMode = isString(mode) && /sync|legacyAsync/.test(mode) ? mode : !mode ? sync : false;
                        req.async = !legacyMode
                    }
                    if (config[p] !== hasCache) {
                        req.rawConfig[p] = config[p];
                        p != "has" && has.add("config-" + p, config[p], 0, booting)
                    }
                }
                if (!req.baseUrl) {
                    req.baseUrl = "./"
                }
                if (!/\/$/.test(req.baseUrl)) {
                    req.baseUrl += "/"
                }
                for (p in config.has) {
                    has.add(p, config.has[p], 0, booting)
                }
                forEach(config.packages, fixupPackageInfo);
                for (var baseUrl in config.packagePaths) {
                    forEach(config.packagePaths[baseUrl], function(packageInfo) {
                        var location = baseUrl + "/" + packageInfo;
                        if (isString(packageInfo)) {
                            packageInfo = {
                                name: packageInfo
                            }
                        }
                        packageInfo.location = location;
                        fixupPackageInfo(packageInfo)
                    })
                }
                computeMapProg(mix(map, config.map), mapProgs);
                forEach(mapProgs, function(item) {
                    item[1] = computeMapProg(item[1], []);
                    if (item[0] == "*") {
                        mapProgs.star = item
                    }
                });
                computeMapProg(mix(paths, config.paths), pathsMapProg);
                computeAliases(config.aliases, aliases);
                if (booting) {
                    delayedModuleConfig.push({
                        config: config.config
                    })
                } else {
                    for (p in config.config) {
                        var module = getModule(p, referenceModule);
                        module.config = mix(module.config || {}, config.config[p])
                    }
                }
                if (config.cache) {
                    consumePendingCacheInsert();
                    pendingCacheInsert = config.cache;
                    if (config.cache["*noref"]) {
                        consumePendingCacheInsert()
                    }
                }
                signal("config", [config, req.rawConfig])
            };
        if (has("dojo-cdn") || 1) {
            var scripts = doc.getElementsByTagName("script"),
                i = 0,
                script, dojoDir, src, match;
            while (i < scripts.length) {
                script = scripts[i++];
                if ((src = script.getAttribute("src")) && (match = src.match(/(((.*)\/)|^)dojo\.js(\W|$)/i))) {
                    dojoDir = match[3] || "";
                    defaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;
                    insertPointSibling = script
                }
                if (src = script.getAttribute("data-dojo-config") || script.getAttribute("djConfig")) {
                    dojoSniffConfig = req.eval("({ " + src + " })", "data-dojo-config");
                    insertPointSibling = script
                }
                if (0) {
                    if (src = script.getAttribute("data-main")) {
                        dojoSniffConfig.deps = dojoSniffConfig.deps || [src]
                    }
                }
            }
        }
        if (0) {
            try {
                if (window.parent != window && window.parent.require) {
                    var doh = window.parent.require("doh");
                    doh && mix(dojoSniffConfig, doh.testConfig)
                }
            } catch (e) {}
        }
        req.rawConfig = {};
        config(defaultConfig, 1);
        if (has("dojo-cdn")) {
            packs.dojo.location = dojoDir;
            if (dojoDir) {
                dojoDir += "/"
            }
            packs.dijit.location = dojoDir + "../dijit/";
            packs.dojox.location = dojoDir + "../dojox/"
        }
        config(userConfig, 1);
        config(dojoSniffConfig, 1)
    } else {
        paths = defaultConfig.paths;
        pathsMapProg = defaultConfig.pathsMapProg;
        packs = defaultConfig.packs;
        aliases = defaultConfig.aliases;
        mapProgs = defaultConfig.mapProgs;
        modules = defaultConfig.modules;
        cache = defaultConfig.cache;
        cacheBust = defaultConfig.cacheBust;
        req.rawConfig = defaultConfig
    }
    if (0) {
        req.combo = req.combo || {
            add: noop
        };
        var comboPending = 0,
            combosPending = [],
            comboPendingTimer = null
    }
    var injectDependencies = function(module) {
            guardCheckComplete(function() {
                forEach(module.deps, injectModule);
                if (0 && comboPending && !comboPendingTimer) {
                    comboPendingTimer = setTimeout(function() {
                        comboPending = 0;
                        comboPendingTimer = null;
                        req.combo.done(function(mids, url) {
                            var onLoadCallback = function() {
                                runDefQ(0, mids);
                                checkComplete()
                            };
                            combosPending.push(mids);
                            injectingModule = mids;
                            req.injectUrl(url, onLoadCallback, mids);
                            injectingModule = 0
                        }, req)
                    }, 0)
                }
            })
        },
        contextRequire = function(a1, a2, a3, referenceModule, contextRequire) {
            var module, syntheticMid;
            if (isString(a1)) {
                module = getModule(a1, referenceModule, true);
                if (module && module.executed) {
                    return module.result
                }
                throw makeError("undefinedModule", a1)
            }
            if (!isArray(a1)) {
                config(a1, 0, referenceModule);
                a1 = a2;
                a2 = a3
            }
            if (isArray(a1)) {
                if (!a1.length) {
                    a2 && a2()
                } else {
                    syntheticMid = "require*" + uid();
                    for (var mid, deps = [], i = 0; i < a1.length;) {
                        mid = a1[i++];
                        deps.push(getModule(mid, referenceModule))
                    }
                    module = mix(makeModuleInfo("", syntheticMid, 0, ""), {
                        injected: arrived,
                        deps: deps,
                        def: a2 || noop,
                        require: referenceModule ? referenceModule.require : req,
                        gc: 1
                    });
                    modules[module.mid] = module;
                    injectDependencies(module);
                    var strict = checkCompleteGuard && legacyMode != sync;
                    guardCheckComplete(function() {
                        execModule(module, strict)
                    });
                    if (!module.executed) {
                        execQ.push(module)
                    }
                    checkComplete()
                }
            }
            return contextRequire
        },
        createRequire = function(module) {
            if (!module) {
                return req
            }
            var result = module.require;
            if (!result) {
                result = function(a1, a2, a3) {
                    return contextRequire(a1, a2, a3, module, result)
                };
                module.require = mix(result, req);
                result.module = module;
                result.toUrl = function(name) {
                    return toUrl(name, module)
                };
                result.toAbsMid = function(mid) {
                    return toAbsMid(mid, module)
                };
                if (0) {
                    result.undef = function(mid) {
                        req.undef(mid, module)
                    }
                }
                if (1) {
                    result.syncLoadNls = function(mid) {
                        var nlsModuleInfo = getModuleInfo(mid, module),
                            nlsModule = modules[nlsModuleInfo.mid];
                        if (!nlsModule || !nlsModule.executed) {
                            cached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];
                            if (cached) {
                                evalModuleText(cached);
                                nlsModule = modules[nlsModuleInfo.mid]
                            }
                        }
                        return nlsModule && nlsModule.executed && nlsModule.result
                    }
                }
            }
            return result
        },
        execQ = [],
        defQ = [],
        waiting = {},
        setRequested = function(module) {
            module.injected = requested;
            waiting[module.mid] = 1;
            if (module.url) {
                waiting[module.url] = module.pack || 1
            }
            startTimer()
        },
        setArrived = function(module) {
            module.injected = arrived;
            delete waiting[module.mid];
            if (module.url) {
                delete waiting[module.url]
            }
            if (isEmpty(waiting)) {
                clearTimer();
                1 && legacyMode == xd && (legacyMode = sync)
            }
        },
        execComplete = req.idle = function() {
            return !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard
        },
        runMapProg = function(targetMid, map) {
            if (map) {
                for (var i = 0; i < map.length; i++) {
                    if (map[i][2].test(targetMid)) {
                        return map[i]
                    }
                }
            }
            return 0
        },
        compactPath = function(path) {
            var result = [],
                segment, lastSegment;
            path = path.replace(/\\/g, "/").split("/");
            while (path.length) {
                segment = path.shift();
                if (segment == ".." && result.length && lastSegment != "..") {
                    result.pop();
                    lastSegment = result[result.length - 1]
                } else if (segment != ".") {
                    result.push(lastSegment = segment)
                }
            }
            return result.join("/")
        },
        makeModuleInfo = function(pid, mid, pack, url) {
            if (1) {
                var xd = req.isXdUrl(url);
                return {
                    pid: pid,
                    mid: mid,
                    pack: pack,
                    url: url,
                    executed: 0,
                    def: 0,
                    isXd: xd,
                    isAmd: !!(xd || packs[pid] && packs[pid].isAmd)
                }
            } else {
                return {
                    pid: pid,
                    mid: mid,
                    pack: pack,
                    url: url,
                    executed: 0,
                    def: 0
                }
            }
        },
        getModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate) {
            var pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;
            requestedMid = mid;
            isRelative = /^\./.test(mid);
            if (/(^\/)|(\:)|(\.js$)/.test(mid) || isRelative && !referenceModule) {
                return makeModuleInfo(0, mid, 0, mid)
            } else {
                mid = compactPath(isRelative ? referenceModule.mid + "/../" + mid : mid);
                if (/^\./.test(mid)) {
                    throw makeError("irrationalPath", mid)
                }
                if (referenceModule) {
                    mapItem = runMapProg(referenceModule.mid, mapProgs)
                }
                mapItem = mapItem || mapProgs.star;
                mapItem = mapItem && runMapProg(mid, mapItem[1]);
                if (mapItem) {
                    mid = mapItem[1] + mid.substring(mapItem[3])
                }
                match = mid.match(/^([^\/]+)(\/(.+))?$/);
                pid = match ? match[1] : "";
                if (pack = packs[pid]) {
                    mid = pid + "/" + (midInPackage = match[3] || pack.main)
                } else {
                    pid = ""
                }
                var candidateLength = 0,
                    candidate = 0;
                forEach(aliases, function(pair) {
                    var match = mid.match(pair[0]);
                    if (match && match.length > candidateLength) {
                        candidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1]
                    }
                });
                if (candidate) {
                    return getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate)
                }
                result = modules[mid];
                if (result) {
                    return alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid]
                }
            }
            mapItem = runMapProg(mid, pathsMapProg);
            if (mapItem) {
                url = mapItem[1] + mid.substring(mapItem[3])
            } else if (pid) {
                url = pack.location + "/" + midInPackage
            } else if (has("config-tlmSiblingOfDojo")) {
                url = "../" + mid
            } else {
                url = mid
            }
            if (!/(^\/)|(\:)/.test(url)) {
                url = baseUrl + url
            }
            url += ".js";
            return makeModuleInfo(pid, mid, pack, compactPath(url))
        },
        getModuleInfo = function(mid, referenceModule, fromPendingCache) {
            return getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, fromPendingCache ? [] : mapProgs, fromPendingCache ? [] : pathsMapProg, fromPendingCache ? [] : aliases)
        },
        resolvePluginResourceId = function(plugin, prid, referenceModule) {
            return plugin.normalize ? plugin.normalize(prid, function(mid) {
                return toAbsMid(mid, referenceModule)
            }) : toAbsMid(prid, referenceModule)
        },
        dynamicPluginUidGenerator = 0,
        getModule = function(mid, referenceModule, immediate) {
            var match, plugin, prid, result;
            match = mid.match(/^(.+?)\!(.*)$/);
            if (match) {
                plugin = getModule(match[1], referenceModule, immediate);
                if (1 && legacyMode == sync && !plugin.executed) {
                    injectModule(plugin);
                    if (plugin.injected === arrived && !plugin.executed) {
                        guardCheckComplete(function() {
                            execModule(plugin)
                        })
                    }
                    if (plugin.executed) {
                        promoteModuleToPlugin(plugin)
                    } else {
                        execQ.unshift(plugin)
                    }
                }
                if (plugin.executed === executed && !plugin.load) {
                    promoteModuleToPlugin(plugin)
                }
                if (plugin.load) {
                    prid = resolvePluginResourceId(plugin, match[2], referenceModule);
                    mid = plugin.mid + "!" + (plugin.dynamic ? ++dynamicPluginUidGenerator + "!" : "") + prid
                } else {
                    prid = match[2];
                    mid = plugin.mid + "!" + ++dynamicPluginUidGenerator + "!waitingForPlugin"
                }
                result = {
                    plugin: plugin,
                    mid: mid,
                    req: createRequire(referenceModule),
                    prid: prid
                }
            } else {
                result = getModuleInfo(mid, referenceModule)
            }
            return modules[result.mid] || !immediate && (modules[result.mid] = result)
        },
        toAbsMid = req.toAbsMid = function(mid, referenceModule) {
            return getModuleInfo(mid, referenceModule).mid
        },
        toUrl = req.toUrl = function(name, referenceModule) {
            var moduleInfo = getModuleInfo(name + "/x", referenceModule),
                url = moduleInfo.url;
            return fixupUrl(moduleInfo.pid === 0 ? name : url.substring(0, url.length - 5))
        },
        nonModuleProps = {
            injected: arrived,
            executed: executed,
            def: nonmodule,
            result: nonmodule
        },
        makeCjs = function(mid) {
            return modules[mid] = mix({
                mid: mid
            }, nonModuleProps)
        },
        cjsRequireModule = makeCjs("require"),
        cjsExportsModule = makeCjs("exports"),
        cjsModuleModule = makeCjs("module"),
        runFactory = function(module, args) {
            req.trace("loader-run-factory", [module.mid]);
            var factory = module.def,
                result;
            1 && syncExecStack.unshift(module);
            if (has("config-dojo-loader-catches")) {
                try {
                    result = isFunction(factory) ? factory.apply(null, args) : factory
                } catch (e) {
                    signal(error, module.result = makeError("factoryThrew", [module, e]))
                }
            } else {
                result = isFunction(factory) ? factory.apply(null, args) : factory
            }
            module.result = result === undefined && module.cjs ? module.cjs.exports : result;
            1 && syncExecStack.shift(module)
        },
        abortExec = {},
        defOrder = 0,
        promoteModuleToPlugin = function(pluginModule) {
            var plugin = pluginModule.result;
            pluginModule.dynamic = plugin.dynamic;
            pluginModule.normalize = plugin.normalize;
            pluginModule.load = plugin.load;
            return pluginModule
        },
        resolvePluginLoadQ = function(plugin) {
            var map = {};
            forEach(plugin.loadQ, function(pseudoPluginResource) {
                var prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),
                    mid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : plugin.mid + "!" + prid,
                    pluginResource = mix(mix({}, pseudoPluginResource), {
                        mid: mid,
                        prid: prid,
                        injected: 0
                    });
                if (!modules[mid]) {
                    injectPlugin(modules[mid] = pluginResource)
                }
                map[pseudoPluginResource.mid] = modules[mid];
                setArrived(pseudoPluginResource);
                delete modules[pseudoPluginResource.mid]
            });
            plugin.loadQ = 0;
            var substituteModules = function(module) {
                for (var replacement, deps = module.deps || [], i = 0; i < deps.length; i++) {
                    replacement = map[deps[i].mid];
                    if (replacement) {
                        deps[i] = replacement
                    }
                }
            };
            for (var p in modules) {
                substituteModules(modules[p])
            }
            forEach(execQ, substituteModules)
        },
        finishExec = function(module) {
            req.trace("loader-finish-exec", [module.mid]);
            module.executed = executed;
            module.defOrder = defOrder++;
            1 && forEach(module.provides, function(cb) {
                cb()
            });
            if (module.loadQ) {
                promoteModuleToPlugin(module);
                resolvePluginLoadQ(module)
            }
            for (i = 0; i < execQ.length;) {
                if (execQ[i] === module) {
                    execQ.splice(i, 1)
                } else {
                    i++
                }
            }
            if (/^require\*/.test(module.mid)) {
                delete modules[module.mid]
            }
        },
        circleTrace = [],
        execModule = function(module, strict) {
            if (module.executed === executing) {
                req.trace("loader-circular-dependency", [circleTrace.concat(module.mid).join("->")]);
                return !module.def || strict ? abortExec : module.cjs && module.cjs.exports
            }
            if (!module.executed) {
                if (!module.def) {
                    return abortExec
                }
                var mid = module.mid,
                    deps = module.deps || [],
                    arg, argResult, args = [],
                    i = 0;
                if (0) {
                    circleTrace.push(mid);
                    req.trace("loader-exec-module", ["exec", circleTrace.length, mid])
                }
                module.executed = executing;
                while (arg = deps[i++]) {
                    argResult = arg === cjsRequireModule ? createRequire(module) : arg === cjsExportsModule ? module.cjs.exports : arg === cjsModuleModule ? module.cjs : execModule(arg, strict);
                    if (argResult === abortExec) {
                        module.executed = 0;
                        req.trace("loader-exec-module", ["abort", mid]);
                        0 && circleTrace.pop();
                        return abortExec
                    }
                    args.push(argResult)
                }
                runFactory(module, args);
                finishExec(module);
                0 && circleTrace.pop()
            }
            return module.result
        },
        checkCompleteGuard = 0,
        guardCheckComplete = function(proc) {
            try {
                checkCompleteGuard++;
                proc()
            } finally {
                checkCompleteGuard--
            }
            if (execComplete()) {
                signal("idle", [])
            }
        },
        checkComplete = function() {
            if (checkCompleteGuard) {
                return
            }
            guardCheckComplete(function() {
                checkDojoRequirePlugin();
                for (var currentDefOrder, module, i = 0; i < execQ.length;) {
                    currentDefOrder = defOrder;
                    module = execQ[i];
                    execModule(module);
                    if (currentDefOrder != defOrder) {
                        checkDojoRequirePlugin();
                        i = 0
                    } else {
                        i++
                    }
                }
            })
        };
    if (0) {
        req.undef = function(moduleId, referenceModule) {
            var module = getModule(moduleId, referenceModule);
            setArrived(module);
            mix(module, {
                def: 0,
                executed: 0,
                injected: 0,
                node: 0
            })
        }
    }
    if (1) {
        if (has("dojo-loader-eval-hint-url") === undefined) {
            has.add("dojo-loader-eval-hint-url", 1)
        }
        var fixupUrl = typeof userConfig.fixupUrl == "function" ? userConfig.fixupUrl : function(url) {
                url += "";
                return url + (cacheBust ? (/\?/.test(url) ? "&" : "?") + cacheBust : "")
            },
            injectPlugin = function(module) {
                var plugin = module.plugin;
                if (plugin.executed === executed && !plugin.load) {
                    promoteModuleToPlugin(plugin)
                }
                var onLoad = function(def) {
                    module.result = def;
                    setArrived(module);
                    finishExec(module);
                    checkComplete()
                };
                if (plugin.load) {
                    plugin.load(module.prid, module.req, onLoad)
                } else if (plugin.loadQ) {
                    plugin.loadQ.push(module)
                } else {
                    plugin.loadQ = [module];
                    execQ.unshift(plugin);
                    injectModule(plugin)
                }
            },
            cached = 0,
            injectingModule = 0,
            injectingCachedModule = 0,
            evalModuleText = function(text, module) {
                if (has("config-stripStrict")) {
                    text = text.replace(/"use strict"/g, "")
                }
                injectingCachedModule = 1;
                if (has("config-dojo-loader-catches")) {
                    try {
                        if (text === cached) {
                            cached.call(null)
                        } else {
                            req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid)
                        }
                    } catch (e) {
                        signal(error, makeError("evalModuleThrew", module))
                    }
                } else {
                    if (text === cached) {
                        cached.call(null)
                    } else {
                        req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid)
                    }
                }
                injectingCachedModule = 0
            },
            injectModule = function(module) {
                var mid = module.mid,
                    url = module.url;
                if (module.executed || module.injected || waiting[mid] || module.url && (module.pack && waiting[module.url] === module.pack || waiting[module.url] == 1)) {
                    return
                }
                setRequested(module);
                if (0) {
                    var viaCombo = 0;
                    if (module.plugin && module.plugin.isCombo) {
                        req.combo.add(module.plugin.mid, module.prid, 0, req);
                        viaCombo = 1
                    } else if (!module.plugin) {
                        viaCombo = req.combo.add(0, module.mid, module.url, req)
                    }
                    if (viaCombo) {
                        comboPending = 1;
                        return
                    }
                }
                if (module.plugin) {
                    injectPlugin(module);
                    return
                }
                var onLoadCallback = function() {
                    runDefQ(module);
                    if (module.injected !== arrived) {
                        if (has("dojo-enforceDefine")) {
                            signal(error, makeError("noDefine", module));
                            return
                        }
                        setArrived(module);
                        mix(module, nonModuleProps);
                        req.trace("loader-define-nonmodule", [module.url])
                    }
                    if (1 && legacyMode) {
                        !syncExecStack.length && checkComplete()
                    } else {
                        checkComplete()
                    }
                };
                cached = cache[mid] || cache[urlKeyPrefix + module.url];
                if (cached) {
                    req.trace("loader-inject", ["cache", module.mid, url]);
                    evalModuleText(cached, module);
                    onLoadCallback();
                    return
                }
                if (1 && legacyMode) {
                    if (module.isXd) {
                        legacyMode == sync && (legacyMode = xd)
                    } else if (module.isAmd && legacyMode != sync) {} else {
                        var xhrCallback = function(text) {
                            if (legacyMode == sync) {
                                syncExecStack.unshift(module);
                                evalModuleText(text, module);
                                syncExecStack.shift();
                                runDefQ(module);
                                if (!module.cjs) {
                                    setArrived(module);
                                    finishExec(module)
                                }
                                if (module.finish) {
                                    var finishMid = mid + "*finish",
                                        finish = module.finish;
                                    delete module.finish;
                                    def(finishMid, ["dojo", ("dojo/require!" + finish.join(",")).replace(/\./g, "/")], function(dojo) {
                                        forEach(finish, function(mid) {
                                            dojo.require(mid)
                                        })
                                    });
                                    execQ.unshift(getModule(finishMid))
                                }
                                onLoadCallback()
                            } else {
                                text = transformToAmd(module, text);
                                if (text) {
                                    evalModuleText(text, module);
                                    onLoadCallback()
                                } else {
                                    injectingModule = module;
                                    req.injectUrl(fixupUrl(url), onLoadCallback, module);
                                    injectingModule = 0
                                }
                            }
                        };
                        req.trace("loader-inject", ["xhr", module.mid, url, legacyMode != sync]);
                        if (has("config-dojo-loader-catches")) {
                            try {
                                req.getText(url, legacyMode != sync, xhrCallback)
                            } catch (e) {
                                signal(error, makeError("xhrInjectFailed", [module, e]))
                            }
                        } else {
                            req.getText(url, legacyMode != sync, xhrCallback)
                        }
                        return
                    }
                }
                req.trace("loader-inject", ["script", module.mid, url]);
                injectingModule = module;
                req.injectUrl(fixupUrl(url), onLoadCallback, module);
                injectingModule = 0
            },
            defineModule = function(module, deps, def) {
                req.trace("loader-define-module", [module.mid, deps]);
                if (0 && module.plugin && module.plugin.isCombo) {
                    module.result = isFunction(def) ? def() : def;
                    setArrived(module);
                    finishExec(module);
                    return module
                }
                var mid = module.mid;
                if (module.injected === arrived) {
                    signal(error, makeError("multipleDefine", module));
                    return module
                }
                mix(module, {
                    deps: deps,
                    def: def,
                    cjs: {
                        id: module.mid,
                        uri: module.url,
                        exports: module.result = {},
                        setExports: function(exports) {
                            module.cjs.exports = exports
                        },
                        config: function() {
                            return module.config
                        }
                    }
                });
                for (var i = 0; deps[i]; i++) {
                    deps[i] = getModule(deps[i], module)
                }
                if (1 && legacyMode && !waiting[mid]) {
                    injectDependencies(module);
                    execQ.push(module);
                    checkComplete()
                }
                setArrived(module);
                if (!isFunction(def) && !deps.length) {
                    module.result = def;
                    finishExec(module)
                }
                return module
            },
            runDefQ = function(referenceModule, mids) {
                var definedModules = [],
                    module, args;
                while (defQ.length) {
                    args = defQ.shift();
                    mids && (args[0] = mids.shift());
                    module = args[0] && getModule(args[0]) || referenceModule;
                    definedModules.push([module, args[1], args[2]])
                }
                consumePendingCacheInsert(referenceModule);
                forEach(definedModules, function(args) {
                    injectDependencies(defineModule.apply(null, args))
                })
            }
    }
    var timerId = 0,
        clearTimer = noop,
        startTimer = noop;
    if (1) {
        clearTimer = function() {
            timerId && clearTimeout(timerId);
            timerId = 0
        };
        startTimer = function() {
            clearTimer();
            if (req.waitms) {
                timerId = global.setTimeout(function() {
                    clearTimer();
                    signal(error, makeError("timeout", waiting))
                }, req.waitms)
            }
        }
    }
    if (1) {
        has.add("ie-event-behavior", doc.attachEvent && typeof Windows === "undefined" && (typeof opera === "undefined" || opera.toString() != "[object Opera]"))
    }
    if (1 && (1 || 1)) {
        var domOn = function(node, eventName, ieEventName, handler) {
                if (!has("ie-event-behavior")) {
                    node.addEventListener(eventName, handler, false);
                    return function() {
                        node.removeEventListener(eventName, handler, false)
                    }
                } else {
                    node.attachEvent(ieEventName, handler);
                    return function() {
                        node.detachEvent(ieEventName, handler)
                    }
                }
            },
            windowOnLoadListener = domOn(window, "load", "onload", function() {
                req.pageLoaded = 1;
                doc.readyState != "complete" && (doc.readyState = "complete");
                windowOnLoadListener()
            });
        if (1) {
            var scripts = doc.getElementsByTagName("script"),
                i = 0,
                script;
            while (!insertPointSibling) {
                if (!/^dojo/.test((script = scripts[i++]) && script.type)) {
                    insertPointSibling = script
                }
            }
            req.injectUrl = function(url, callback, owner) {
                var node = owner.node = doc.createElement("script"),
                    onLoad = function(e) {
                        e = e || window.event;
                        var node = e.target || e.srcElement;
                        if (e.type === "load" || /complete|loaded/.test(node.readyState)) {
                            loadDisconnector();
                            errorDisconnector();
                            callback && callback()
                        }
                    },
                    loadDisconnector = domOn(node, "load", "onreadystatechange", onLoad),
                    errorDisconnector = domOn(node, "error", "onerror", function(e) {
                        loadDisconnector();
                        errorDisconnector();
                        signal(error, makeError("scriptError", [url, e]))
                    });
                node.type = "text/javascript";
                node.charset = "utf-8";
                node.src = url;
                insertPointSibling.parentNode.insertBefore(node, insertPointSibling);
                return node
            }
        }
    }
    if (1) {
        req.log = function() {
            try {
                for (var i = 0; i < arguments.length; i++) {
                    console.log(arguments[i])
                }
            } catch (e) {}
        }
    } else {
        req.log = noop
    }
    if (0) {
        var trace = req.trace = function(group, args) {
            if (trace.on && trace.group[group]) {
                signal("trace", [group, args]);
                for (var arg, dump = [], text = "trace:" + group + (args.length ? ":" + args[0] : ""), i = 1; i < args.length;) {
                    arg = args[i++];
                    if (isString(arg)) {
                        text += ", " + arg
                    } else {
                        dump.push(arg)
                    }
                }
                req.log(text);
                dump.length && dump.push(".");
                req.log.apply(req, dump)
            }
        };
        mix(trace, {
            on: 1,
            group: {},
            set: function(group, value) {
                if (isString(group)) {
                    trace.group[group] = value
                } else {
                    mix(trace.group, group)
                }
            }
        });
        trace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));
        on("config", function(config) {
            config.trace && trace.set(config.trace)
        })
    } else {
        req.trace = noop
    }
    var def = function(mid, dependencies, factory) {
        var arity = arguments.length,
            defaultDeps = ["require", "exports", "module"],
            args = [0, mid, dependencies];
        if (arity == 1) {
            args = [0, isFunction(mid) ? defaultDeps : [], mid]
        } else if (arity == 2 && isString(mid)) {
            args = [mid, isFunction(dependencies) ? defaultDeps : [], dependencies]
        } else if (arity == 3) {
            args = [mid, dependencies, factory]
        }
        if (0 && args[1] === defaultDeps) {
            args[2].toString().replace(/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/gm, "").replace(/require\(["']([\w\!\-_\.\/]+)["']\)/g, function(match, dep) {
                args[1].push(dep)
            })
        }
        req.trace("loader-define", args.slice(0, 2));
        var targetModule = args[0] && getModule(args[0]),
            module;
        if (targetModule && !waiting[targetModule.mid]) {
            injectDependencies(defineModule(targetModule, args[1], args[2]))
        } else if (!has("ie-event-behavior") || !1 || injectingCachedModule) {
            defQ.push(args)
        } else {
            targetModule = targetModule || injectingModule;
            if (!targetModule) {
                for (mid in waiting) {
                    module = modules[mid];
                    if (module && module.node && module.node.readyState === "interactive") {
                        targetModule = module;
                        break
                    }
                }
                if (0 && !targetModule) {
                    for (var i = 0; i < combosPending.length; i++) {
                        targetModule = combosPending[i];
                        if (targetModule.node && targetModule.node.readyState === "interactive") {
                            break
                        }
                        targetModule = 0
                    }
                }
            }
            if (0 && isArray(targetModule)) {
                injectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));
                if (!targetModule.length) {
                    combosPending.splice(i, 1)
                }
            } else if (targetModule) {
                consumePendingCacheInsert(targetModule);
                injectDependencies(defineModule(targetModule, args[1], args[2]))
            } else {
                signal(error, makeError("ieDefineFailed", args[0]))
            }
            checkComplete()
        }
    };
    def.amd = {
        vendor: "dojotoolkit.org"
    };
    if (0) {
        req.def = def
    }
    mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);
    on(error, function(arg) {
        try {
            console.error(arg);
            if (arg instanceof Error) {
                for (var p in arg) {
                    console.log(p + ":", arg[p])
                }
                console.log(".")
            }
        } catch (e) {}
    });
    mix(req, {
        uid: uid,
        cache: cache,
        packs: packs
    });
    if (0) {
        mix(req, {
            paths: paths,
            aliases: aliases,
            modules: modules,
            legacyMode: legacyMode,
            execQ: execQ,
            defQ: defQ,
            waiting: waiting,
            packs: packs,
            mapProgs: mapProgs,
            pathsMapProg: pathsMapProg,
            listenerQueues: listenerQueues,
            computeMapProg: computeMapProg,
            computeAliases: computeAliases,
            runMapProg: runMapProg,
            compactPath: compactPath,
            getModuleInfo: getModuleInfo_
        })
    }
    if (global.define) {
        if (1) {
            signal(error, makeError("defineAlreadyDefined", 0))
        }
        return
    } else {
        global.define = def;
        global.require = req;
        if (0) {
            require = req
        }
    }
    if (0 && req.combo && req.combo.plugins) {
        var plugins = req.combo.plugins,
            pluginName;
        for (pluginName in plugins) {
            mix(mix(getModule(pluginName), plugins[pluginName]), {
                isCombo: 1,
                executed: "executed",
                load: 1
            })
        }
    }
    if (1) {
        forEach(delayedModuleConfig, function(c) {
            config(c)
        });
        var bootDeps = dojoSniffConfig.deps || userConfig.deps || defaultConfig.deps,
            bootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;
        req.boot = bootDeps || bootCallback ? [bootDeps || [], bootCallback] : 0
    }
    if (!1) {
        !req.async && req(["dojo"]);
        req.boot && req.apply(null, req.boot)
    }
})(this.dojoConfig || this.djConfig || this.require || {}, {
    async: true,
    hasCache: {
        "config-selectorEngine": "lite",
        "config-tlmSiblingOfDojo": 1,
        "dojo-built": 1,
        "dojo-loader": 1,
        dom: 1,
        "host-browser": 1
    },
    packages: [{
        location: ".",
        name: "dojo"
    }, {
        location: "../gyro",
        name: "gyro"
    }, {
        location: "../pixi",
        name: "pixi"
    }, {
        location: "../ion",
        name: "ion"
    }]
});
require({
    cache: {
        "dojo/main": function() {
            define(["./_base/kernel", "./has", "require", "./sniff", "./_base/lang", "./_base/array", "./_base/config", "./ready", "./_base/declare", "./_base/connect", "./_base/Deferred", "./_base/json", "./_base/Color", "./has!dojo-firebug?./_firebug/firebug", "./_base/browser", "./_base/loader"], function(kernel, has, require, sniff, lang, array, config, ready) {
                if (config.isDebug) {
                    require(["./_firebug/firebug"])
                }
                1 || has.add("dojo-config-require", 1);
                if (1) {
                    var deps = config.require;
                    if (deps) {
                        deps = array.map(lang.isArray(deps) ? deps : [deps], function(item) {
                            return item.replace(/\./g, "/")
                        });
                        if (kernel.isAsync) {
                            require(deps)
                        } else {
                            ready(1, function() {
                                require(deps)
                            })
                        }
                    }
                }
                return kernel
            })
        },
        "dojo/_base/kernel": function() {
            define(["../has", "./config", "require", "module"], function(has, config, require, module) {
                var i, p, global = function() {
                        return this
                    }(),
                    dijit = {},
                    dojox = {},
                    dojo = {
                        config: config,
                        global: global,
                        dijit: dijit,
                        dojox: dojox
                    };
                var scopeMap = {
                        dojo: ["dojo", dojo],
                        dijit: ["dijit", dijit],
                        dojox: ["dojox", dojox]
                    },
                    packageMap = require.map && require.map[module.id.match(/[^\/]+/)[0]],
                    item;
                for (p in packageMap) {
                    if (scopeMap[p]) {
                        scopeMap[p][0] = packageMap[p]
                    } else {
                        scopeMap[p] = [packageMap[p], {}]
                    }
                }
                for (p in scopeMap) {
                    item = scopeMap[p];
                    item[1]._scopeName = item[0];
                    if (!config.noGlobals) {
                        global[item[0]] = item[1]
                    }
                }
                dojo.scopeMap = scopeMap;
                dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
                dojo.isAsync = !1 || require.async;
                dojo.locale = config.locale;
                var rev = "$Rev: ae6be82 $".match(/[0-9a-f]{7,}/);
                dojo.version = {
                    major: 1,
                    minor: 10,
                    patch: 3,
                    flag: "",
                    revision: rev ? rev[0] : NaN,
                    toString: function() {
                        var v = dojo.version;
                        return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")"
                    }
                };
                1 || has.add("extend-dojo", 1);
                Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}")(dojo);
                if (0) {
                    dojo.exit = function(exitcode) {
                        quit(exitcode)
                    }
                } else {
                    dojo.exit = function() {}
                }
                1 || has.add("dojo-guarantee-console", 1);
                if (1) {
                    typeof console != "undefined" || (console = {});
                    var cn = ["assert", "count", "debug", "dir", "dirxml", "error", "group", "groupEnd", "info", "profile", "profileEnd", "time", "timeEnd", "trace", "warn", "log"];
                    var tn;
                    i = 0;
                    while (tn = cn[i++]) {
                        if (!console[tn]) {
                            (function() {
                                var tcn = tn + "";
                                console[tcn] = "log" in console ? function() {
                                    var a = Array.prototype.slice.call(arguments);
                                    a.unshift(tcn + ":");
                                    console["log"](a.join(" "))
                                } : function() {};
                                console[tcn]._fake = true
                            })()
                        }
                    }
                }
                has.add("dojo-debug-messages", !!config.isDebug);
                dojo.deprecated = dojo.experimental = function() {};
                if (has("dojo-debug-messages")) {
                    dojo.deprecated = function(behaviour, extra, removal) {
                        var message = "DEPRECATED: " + behaviour;
                        if (extra) {
                            message += " " + extra
                        }
                        if (removal) {
                            message += " -- will be removed in version: " + removal
                        }
                        console.warn(message)
                    };
                    dojo.experimental = function(moduleName, extra) {
                        var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
                        if (extra) {
                            message += " " + extra
                        }
                        console.warn(message)
                    }
                }
                1 || has.add("dojo-modulePaths", 1);
                if (1) {
                    if (config.modulePaths) {
                        dojo.deprecated("dojo.modulePaths", "use paths configuration");
                        var paths = {};
                        for (p in config.modulePaths) {
                            paths[p.replace(/\./g, "/")] = config.modulePaths[p]
                        }
                        require({
                            paths: paths
                        })
                    }
                }
                1 || has.add("dojo-moduleUrl", 1);
                if (1) {
                    dojo.moduleUrl = function(module, url) {
                        dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");
                        var result = null;
                        if (module) {
                            result = require.toUrl(module.replace(/\./g, "/") + (url ? "/" + url : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/")
                        }
                        return result
                    }
                }
                dojo._hasResource = {};
                return dojo
            })
        },
        "dojo/has": function() {
            define(["require", "module"], function(require, module) {
                var has = require.has || function() {};
                if (!1) {
                    var isBrowser = typeof window != "undefined" && typeof location != "undefined" && typeof document != "undefined" && window.location == location && window.document == document,
                        global = function() {
                            return this
                        }(),
                        doc = isBrowser && document,
                        element = doc && doc.createElement("DiV"),
                        cache = module.config && module.config() || {};
                    has = function(name) {
                        return typeof cache[name] == "function" ? cache[name] = cache[name](global, doc, element) : cache[name]
                    };
                    has.cache = cache;
                    has.add = function(name, test, now, force) {
                        (typeof cache[name] == "undefined" || force) && (cache[name] = test);
                        return now && has(name)
                    };
                    1 || has.add("host-browser", isBrowser);
                    0 && has.add("host-node", typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
                    0 && has.add("host-rhino", typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object"));
                    1 || has.add("dom", isBrowser);
                    1 || has.add("dojo-dom-ready-api", 1);
                    1 || has.add("dojo-sniff", 1)
                }
                if (1) {
                    has.add("dom-addeventlistener", !!document.addEventListener);
                    has.add("touch", "ontouchstart" in document || "onpointerdown" in document && navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints);
                    has.add("touch-events", "ontouchstart" in document);
                    has.add("pointer-events", "onpointerdown" in document);
                    has.add("MSPointer", "msMaxTouchPoints" in navigator);
                    has.add("device-width", screen.availWidth || innerWidth);
                    var form = document.createElement("form");
                    has.add("dom-attributes-explicit", form.attributes.length == 0);
                    has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40)
                }
                has.clearElement = function(element) {
                    element.innerHTML = "";
                    return element
                };
                has.normalize = function(id, toAbsMid) {
                    var tokens = id.match(/[\?:]|[^:\?]*/g),
                        i = 0,
                        get = function(skip) {
                            var term = tokens[i++];
                            if (term == ":") {
                                return 0
                            } else {
                                if (tokens[i++] == "?") {
                                    if (!skip && has(term)) {
                                        return get()
                                    } else {
                                        get(true);
                                        return get(skip)
                                    }
                                }
                                return term || 0
                            }
                        };
                    id = get();
                    return id && toAbsMid(id)
                };
                has.load = function(id, parentRequire, loaded) {
                    if (id) {
                        parentRequire([id], loaded)
                    } else {
                        loaded()
                    }
                };
                return has
            })
        },
        "dojo/_base/config": function() {
            define(["../has", "require"], function(has, require) {
                var result = {};
                if (1) {
                    var src = require.rawConfig,
                        p;
                    for (p in src) {
                        result[p] = src[p]
                    }
                } else {
                    var adviseHas = function(featureSet, prefix, booting) {
                        for (p in featureSet) {
                            p != "has" && has.add(prefix + p, featureSet[p], 0, booting)
                        }
                    };
                    var global = function() {
                        return this
                    }();
                    result = 1 ? require.rawConfig : global.dojoConfig || global.djConfig || {};
                    adviseHas(result, "config", 1);
                    adviseHas(result.has, "", 1)
                }
                if (!result.locale && typeof navigator != "undefined") {
                    var language = navigator.language || navigator.userLanguage;
                    if (language) {
                        result.locale = language.toLowerCase()
                    }
                }
                return result
            })
        },
        "dojo/sniff": function() {
            define(["./has"], function(has) {
                if (1) {
                    var n = navigator,
                        dua = n.userAgent,
                        dav = n.appVersion,
                        tv = parseFloat(dav);
                    has.add("air", dua.indexOf("AdobeAIR") >= 0);
                    has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
                    has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
                    has.add("webkit", parseFloat(dua.split("WebKit/")[1]) || undefined);
                    has.add("chrome", parseFloat(dua.split("Chrome/")[1]) || undefined);
                    has.add("safari", dav.indexOf("Safari") >= 0 && !has("chrome") ? parseFloat(dav.split("Version/")[1]) : undefined);
                    has.add("mac", dav.indexOf("Macintosh") >= 0);
                    has.add("quirks", document.compatMode == "BackCompat");
                    if (dua.match(/(iPhone|iPod|iPad)/)) {
                        var p = RegExp.$1.replace(/P/, "p");
                        var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
                        var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
                        has.add(p, os);
                        has.add("ios", os)
                    }
                    has.add("android", parseFloat(dua.split("Android ")[1]) || undefined);
                    has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
                    has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);
                    has.add("svg", typeof SVGAngle !== "undefined");
                    if (!has("webkit")) {
                        if (dua.indexOf("Opera") >= 0) {
                            has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv)
                        }
                        if (dua.indexOf("Gecko") >= 0 && !has("khtml") && !has("webkit") && !has("trident")) {
                            has.add("mozilla", tv)
                        }
                        if (has("mozilla")) {
                            has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined)
                        }
                        if (document.all && !has("opera")) {
                            var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;
                            var mode = document.documentMode;
                            if (mode && mode != 5 && Math.floor(isIE) != mode) {
                                isIE = mode
                            }
                            has.add("ie", isIE)
                        }
                        has.add("wii", typeof opera != "undefined" && opera.wiiremote)
                    }
                }
                return has
            })
        },
        "dojo/_base/lang": function() {
            define(["./kernel", "../has", "../sniff"], function(dojo, has) {
                has.add("bug-for-in-skips-shadowed", function() {
                    for (var i in {
                            toString: 1
                        }) {
                        return 0
                    }
                    return 1
                });
                var _extraNames = has("bug-for-in-skips-shadowed") ? "hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],
                    _extraLen = _extraNames.length,
                    getProp = function(parts, create, context) {
                        if (!context) {
                            if (parts[0] && dojo.scopeMap[parts[0]]) {
                                context = dojo.scopeMap[parts.shift()][1]
                            } else {
                                context = dojo.global
                            }
                        }
                        try {
                            for (var i = 0; i < parts.length; i++) {
                                var p = parts[i];
                                if (!(p in context)) {
                                    if (create) {
                                        context[p] = {}
                                    } else {
                                        return
                                    }
                                }
                                context = context[p]
                            }
                            return context
                        } catch (e) {}
                    },
                    opts = Object.prototype.toString,
                    efficient = function(obj, offset, startWith) {
                        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0))
                    },
                    _pattern = /\{([^\}]+)\}/g;
                var lang = {
                    _extraNames: _extraNames,
                    _mixin: function(dest, source, copyFunc) {
                        var name, s, i, empty = {};
                        for (name in source) {
                            s = source[name];
                            if (!(name in dest) || dest[name] !== s && (!(name in empty) || empty[name] !== s)) {
                                dest[name] = copyFunc ? copyFunc(s) : s
                            }
                        }
                        if (has("bug-for-in-skips-shadowed")) {
                            if (source) {
                                for (i = 0; i < _extraLen; ++i) {
                                    name = _extraNames[i];
                                    s = source[name];
                                    if (!(name in dest) || dest[name] !== s && (!(name in empty) || empty[name] !== s)) {
                                        dest[name] = copyFunc ? copyFunc(s) : s
                                    }
                                }
                            }
                        }
                        return dest
                    },
                    mixin: function(dest, sources) {
                        if (!dest) {
                            dest = {}
                        }
                        for (var i = 1, l = arguments.length; i < l; i++) {
                            lang._mixin(dest, arguments[i])
                        }
                        return dest
                    },
                    setObject: function(name, value, context) {
                        var parts = name.split("."),
                            p = parts.pop(),
                            obj = getProp(parts, true, context);
                        return obj && p ? obj[p] = value : undefined
                    },
                    getObject: function(name, create, context) {
                        return getProp(name ? name.split(".") : [], create, context)
                    },
                    exists: function(name, obj) {
                        return lang.getObject(name, false, obj) !== undefined
                    },
                    isString: function(it) {
                        return typeof it == "string" || it instanceof String
                    },
                    isArray: function(it) {
                        return it && (it instanceof Array || typeof it == "array")
                    },
                    isFunction: function(it) {
                        return opts.call(it) === "[object Function]"
                    },
                    isObject: function(it) {
                        return it !== undefined && (it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it))
                    },
                    isArrayLike: function(it) {
                        return it && it !== undefined && !lang.isString(it) && !lang.isFunction(it) && !(it.tagName && it.tagName.toLowerCase() == "form") && (lang.isArray(it) || isFinite(it.length))
                    },
                    isAlien: function(it) {
                        return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it))
                    },
                    extend: function(ctor, props) {
                        for (var i = 1, l = arguments.length; i < l; i++) {
                            lang._mixin(ctor.prototype, arguments[i])
                        }
                        return ctor
                    },
                    _hitchArgs: function(scope, method) {
                        var pre = lang._toArray(arguments, 2);
                        var named = lang.isString(method);
                        return function() {
                            var args = lang._toArray(arguments);
                            var f = named ? (scope || dojo.global)[method] : method;
                            return f && f.apply(scope || this, pre.concat(args))
                        }
                    },
                    hitch: function(scope, method) {
                        if (arguments.length > 2) {
                            return lang._hitchArgs.apply(dojo, arguments)
                        }
                        if (!method) {
                            method = scope;
                            scope = null
                        }
                        if (lang.isString(method)) {
                            scope = scope || dojo.global;
                            if (!scope[method]) {
                                throw ['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join("")
                            }
                            return function() {
                                return scope[method].apply(scope, arguments || [])
                            }
                        }
                        return !scope ? method : function() {
                            return method.apply(scope, arguments || [])
                        }
                    },
                    delegate: function() {
                        function TMP() {}
                        return function(obj, props) {
                            TMP.prototype = obj;
                            var tmp = new TMP;
                            TMP.prototype = null;
                            if (props) {
                                lang._mixin(tmp, props)
                            }
                            return tmp
                        }
                    }(),
                    _toArray: has("ie") ? function() {
                        function slow(obj, offset, startWith) {
                            var arr = startWith || [];
                            for (var x = offset || 0; x < obj.length; x++) {
                                arr.push(obj[x])
                            }
                            return arr
                        }
                        return function(obj) {
                            return (obj.item ? slow : efficient).apply(this, arguments)
                        }
                    }() : efficient,
                    partial: function(method) {
                        var arr = [null];
                        return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments)))
                    },
                    clone: function(src) {
                        if (!src || typeof src != "object" || lang.isFunction(src)) {
                            return src
                        }
                        if (src.nodeType && "cloneNode" in src) {
                            return src.cloneNode(true)
                        }
                        if (src instanceof Date) {
                            return new Date(src.getTime())
                        }
                        if (src instanceof RegExp) {
                            return new RegExp(src)
                        }
                        var r, i, l;
                        if (lang.isArray(src)) {
                            r = [];
                            for (i = 0, l = src.length; i < l; ++i) {
                                if (i in src) {
                                    r.push(lang.clone(src[i]))
                                }
                            }
                        } else {
                            r = src.constructor ? new src.constructor : {}
                        }
                        return lang._mixin(r, src, lang.clone)
                    },
                    trim: String.prototype.trim ? function(str) {
                        return str.trim()
                    } : function(str) {
                        return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
                    },
                    replace: function(tmpl, map, pattern) {
                        return tmpl.replace(pattern || _pattern, lang.isFunction(map) ? map : function(_, k) {
                            return lang.getObject(k, false, map)
                        })
                    }
                };
                1 && lang.mixin(dojo, lang);
                return lang
            })
        },
        "dojo/_base/array": function() {
            define(["./kernel", "../has", "./lang"], function(dojo, has, lang) {
                var cache = {},
                    u;

                function buildFn(fn) {
                    return cache[fn] = new Function("item", "index", "array", fn)
                }

                function everyOrSome(some) {
                    var every = !some;
                    return function(a, fn, o) {
                        var i = 0,
                            l = a && a.length || 0,
                            result;
                        if (l && typeof a == "string") a = a.split("");
                        if (typeof fn == "string") fn = cache[fn] || buildFn(fn);
                        if (o) {
                            for (; i < l; ++i) {
                                result = !fn.call(o, a[i], i, a);
                                if (some ^ result) {
                                    return !result
                                }
                            }
                        } else {
                            for (; i < l; ++i) {
                                result = !fn(a[i], i, a);
                                if (some ^ result) {
                                    return !result
                                }
                            }
                        }
                        return every
                    }
                }

                function index(up) {
                    var delta = 1,
                        lOver = 0,
                        uOver = 0;
                    if (!up) {
                        delta = lOver = uOver = -1
                    }
                    return function(a, x, from, last) {
                        if (last && delta > 0) {
                            return array.lastIndexOf(a, x, from)
                        }
                        var l = a && a.length || 0,
                            end = up ? l + uOver : lOver,
                            i;
                        if (from === u) {
                            i = up ? lOver : l + uOver
                        } else {
                            if (from < 0) {
                                i = l + from;
                                if (i < 0) {
                                    i = lOver
                                }
                            } else {
                                i = from >= l ? l + uOver : from
                            }
                        }
                        if (l && typeof a == "string") a = a.split("");
                        for (; i != end; i += delta) {
                            if (a[i] == x) {
                                return i
                            }
                        }
                        return -1
                    }
                }
                var array = {
                    every: everyOrSome(false),
                    some: everyOrSome(true),
                    indexOf: index(true),
                    lastIndexOf: index(false),
                    forEach: function(arr, callback, thisObject) {
                        var i = 0,
                            l = arr && arr.length || 0;
                        if (l && typeof arr == "string") arr = arr.split("");
                        if (typeof callback == "string") callback = cache[callback] || buildFn(callback);
                        if (thisObject) {
                            for (; i < l; ++i) {
                                callback.call(thisObject, arr[i], i, arr)
                            }
                        } else {
                            for (; i < l; ++i) {
                                callback(arr[i], i, arr)
                            }
                        }
                    },
                    map: function(arr, callback, thisObject, Ctr) {
                        var i = 0,
                            l = arr && arr.length || 0,
                            out = new(Ctr || Array)(l);
                        if (l && typeof arr == "string") arr = arr.split("");
                        if (typeof callback == "string") callback = cache[callback] || buildFn(callback);
                        if (thisObject) {
                            for (; i < l; ++i) {
                                out[i] = callback.call(thisObject, arr[i], i, arr)
                            }
                        } else {
                            for (; i < l; ++i) {
                                out[i] = callback(arr[i], i, arr)
                            }
                        }
                        return out
                    },
                    filter: function(arr, callback, thisObject) {
                        var i = 0,
                            l = arr && arr.length || 0,
                            out = [],
                            value;
                        if (l && typeof arr == "string") arr = arr.split("");
                        if (typeof callback == "string") callback = cache[callback] || buildFn(callback);
                        if (thisObject) {
                            for (; i < l; ++i) {
                                value = arr[i];
                                if (callback.call(thisObject, value, i, arr)) {
                                    out.push(value)
                                }
                            }
                        } else {
                            for (; i < l; ++i) {
                                value = arr[i];
                                if (callback(value, i, arr)) {
                                    out.push(value)
                                }
                            }
                        }
                        return out
                    },
                    clearCache: function() {
                        cache = {}
                    }
                };
                1 && lang.mixin(dojo, array);
                return array
            })
        },
        "dojo/ready": function() {
            define(["./_base/kernel", "./has", "require", "./domReady", "./_base/lang"], function(dojo, has, require, domReady, lang) {
                var isDomReady = 0,
                    loadQ = [],
                    onLoadRecursiveGuard = 0,
                    handleDomReady = function() {
                        isDomReady = 1;
                        dojo._postLoad = dojo.config.afterOnLoad = true;
                        onEvent()
                    },
                    onEvent = function() {
                        if (onLoadRecursiveGuard) {
                            return
                        }
                        onLoadRecursiveGuard = 1;
                        while (isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length) {
                            var f = loadQ.shift();
                            try {
                                f()
                            } catch (e) {
                                e.info = e.message;
                                if (require.signal) {
                                    require.signal("error", e)
                                } else {
                                    throw e
                                }
                            }
                        }
                        onLoadRecursiveGuard = 0
                    };
                require.on && require.on("idle", onEvent);
                if (domReady) {
                    domReady._onQEmpty = onEvent
                }
                var ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback) {
                    var hitchArgs = lang._toArray(arguments);
                    if (typeof priority != "number") {
                        callback = context;
                        context = priority;
                        priority = 1e3
                    } else {
                        hitchArgs.shift()
                    }
                    callback = callback ? lang.hitch.apply(dojo, hitchArgs) : function() {
                        context()
                    };
                    callback.priority = priority;
                    for (var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++) {}
                    loadQ.splice(i, 0, callback);
                    onEvent()
                };
                1 || has.add("dojo-config-addOnLoad", 1);
                if (1) {
                    var dca = dojo.config.addOnLoad;
                    if (dca) {
                        ready[lang.isArray(dca) ? "apply" : "call"](dojo, dca)
                    }
                }
                if (1 && dojo.config.parseOnLoad && !dojo.isAsync) {
                    ready(99, function() {
                        if (!dojo.parser) {
                            dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
                            require(["dojo/parser"])
                        }
                    })
                }
                if (domReady) {
                    domReady(handleDomReady)
                } else {
                    handleDomReady()
                }
                return ready
            })
        },
        "dojo/domReady": function() {
            define(["./has"], function(has) {
                var global = function() {
                        return this
                    }(),
                    doc = document,
                    readyStates = {
                        loaded: 1,
                        complete: 1
                    },
                    fixReadyState = typeof doc.readyState != "string",
                    ready = !!readyStates[doc.readyState],
                    readyQ = [],
                    recursiveGuard;

                function domReady(callback) {
                    readyQ.push(callback);
                    if (ready) {
                        processQ()
                    }
                }
                domReady.load = function(id, req, load) {
                    domReady(load)
                };
                domReady._Q = readyQ;
                domReady._onQEmpty = function() {};
                if (fixReadyState) {
                    doc.readyState = "loading"
                }

                function processQ() {
                    if (recursiveGuard) {
                        return
                    }
                    recursiveGuard = true;
                    while (readyQ.length) {
                        try {
                            readyQ.shift()(doc)
                        } catch (err) {
                            console.error(err, "in domReady callback", err.stack)
                        }
                    }
                    recursiveGuard = false;
                    domReady._onQEmpty()
                }
                if (!ready) {
                    var tests = [],
                        detectReady = function(evt) {
                            evt = evt || global.event;
                            if (ready || evt.type == "readystatechange" && !readyStates[doc.readyState]) {
                                return
                            }
                            if (fixReadyState) {
                                doc.readyState = "complete"
                            }
                            ready = 1;
                            processQ()
                        },
                        on = function(node, event) {
                            node.addEventListener(event, detectReady, false);
                            readyQ.push(function() {
                                node.removeEventListener(event, detectReady, false)
                            })
                        };
                    if (!has("dom-addeventlistener")) {
                        on = function(node, event) {
                            event = "on" + event;
                            node.attachEvent(event, detectReady);
                            readyQ.push(function() {
                                node.detachEvent(event, detectReady)
                            })
                        };
                        var div = doc.createElement("div");
                        try {
                            if (div.doScroll && global.frameElement === null) {
                                tests.push(function() {
                                    try {
                                        div.doScroll("left");
                                        return 1
                                    } catch (e) {}
                                })
                            }
                        } catch (e) {}
                    }
                    on(doc, "DOMContentLoaded");
                    on(global, "load");
                    if ("onreadystatechange" in doc) {
                        on(doc, "readystatechange")
                    } else if (!fixReadyState) {
                        tests.push(function() {
                            return readyStates[doc.readyState]
                        })
                    }
                    if (tests.length) {
                        var poller = function() {
                            if (ready) {
                                return
                            }
                            var i = tests.length;
                            while (i--) {
                                if (tests[i]()) {
                                    detectReady("poller");
                                    return
                                }
                            }
                            setTimeout(poller, 30)
                        };
                        poller()
                    }
                }
                return domReady
            })
        },
        "dojo/_base/declare": function() {
            define(["./kernel", "../has", "./lang"], function(dojo, has, lang) {
                var mix = lang.mixin,
                    op = Object.prototype,
                    opts = op.toString,
                    xtor = new Function,
                    counter = 0,
                    cname = "constructor";

                function err(msg, cls) {
                    throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg)
                }

                function c3mro(bases, className) {
                    var result = [],
                        roots = [{
                            cls: 0,
                            refs: []
                        }],
                        nameMap = {},
                        clsCount = 1,
                        l = bases.length,
                        i = 0,
                        j, lin, base, top, proto, rec, name, refs;
                    for (; i < l; ++i) {
                        base = bases[i];
                        if (!base) {
                            err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className)
                        } else if (opts.call(base) != "[object Function]") {
                            err("mixin #" + i + " is not a callable constructor.", className)
                        }
                        lin = base._meta ? base._meta.bases : [base];
                        top = 0;
                        for (j = lin.length - 1; j >= 0; --j) {
                            proto = lin[j].prototype;
                            if (!proto.hasOwnProperty("declaredClass")) {
                                proto.declaredClass = "uniqName_" + counter++
                            }
                            name = proto.declaredClass;
                            if (!nameMap.hasOwnProperty(name)) {
                                nameMap[name] = {
                                    count: 0,
                                    refs: [],
                                    cls: lin[j]
                                };
                                ++clsCount
                            }
                            rec = nameMap[name];
                            if (top && top !== rec) {
                                rec.refs.push(top);
                                ++top.count
                            }
                            top = rec
                        }++top.count;
                        roots[0].refs.push(top)
                    }
                    while (roots.length) {
                        top = roots.pop();
                        result.push(top.cls);
                        --clsCount;
                        while (refs = top.refs, refs.length == 1) {
                            top = refs[0];
                            if (!top || --top.count) {
                                top = 0;
                                break
                            }
                            result.push(top.cls);
                            --clsCount
                        }
                        if (top) {
                            for (i = 0, l = refs.length; i < l; ++i) {
                                top = refs[i];
                                if (!--top.count) {
                                    roots.push(top)
                                }
                            }
                        }
                    }
                    if (clsCount) {
                        err("can't build consistent linearization", className)
                    }
                    base = bases[0];
                    result[0] = base ? base._meta && base === result[result.length - base._meta.bases.length] ? base._meta.bases.length : 1 : 0;
                    return result
                }

                function inherited(args, a, f) {
                    var name, chains, bases, caller, meta, base, proto, opf, pos, cache = this._inherited = this._inherited || {};
                    if (typeof args == "string") {
                        name = args;
                        args = a;
                        a = f
                    }
                    f = 0;
                    caller = args.callee;
                    name = name || caller.nom;
                    if (!name) {
                        err("can't deduce a name to call inherited()", this.declaredClass)
                    }
                    meta = this.constructor._meta;
                    bases = meta.bases;
                    pos = cache.p;
                    if (name != cname) {
                        if (cache.c !== caller) {
                            pos = 0;
                            base = bases[0];
                            meta = base._meta;
                            if (meta.hidden[name] !== caller) {
                                chains = meta.chains;
                                if (chains && typeof chains[name] == "string") {
                                    err("calling chained method with inherited: " + name, this.declaredClass)
                                }
                                do {
                                    meta = base._meta;
                                    proto = base.prototype;
                                    if (meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)) {
                                        break
                                    }
                                } while (base = bases[++pos]);
                                pos = base ? pos : -1
                            }
                        }
                        base = bases[++pos];
                        if (base) {
                            proto = base.prototype;
                            if (base._meta && proto.hasOwnProperty(name)) {
                                f = proto[name]
                            } else {
                                opf = op[name];
                                do {
                                    proto = base.prototype;
                                    f = proto[name];
                                    if (f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)) {
                                        break
                                    }
                                } while (base = bases[++pos])
                            }
                        }
                        f = base && f || op[name]
                    } else {
                        if (cache.c !== caller) {
                            pos = 0;
                            meta = bases[0]._meta;
                            if (meta && meta.ctor !== caller) {
                                chains = meta.chains;
                                if (!chains || chains.constructor !== "manual") {
                                    err("calling chained constructor with inherited", this.declaredClass)
                                }
                                while (base = bases[++pos]) {
                                    meta = base._meta;
                                    if (meta && meta.ctor === caller) {
                                        break
                                    }
                                }
                                pos = base ? pos : -1
                            }
                        }
                        while (base = bases[++pos]) {
                            meta = base._meta;
                            f = meta ? meta.ctor : base;
                            if (f) {
                                break
                            }
                        }
                        f = base && f
                    }
                    cache.c = f;
                    cache.p = pos;
                    if (f) {
                        return a === true ? f : f.apply(this, a || args)
                    }
                }

                function getInherited(name, args) {
                    if (typeof name == "string") {
                        return this.__inherited(name, args, true)
                    }
                    return this.__inherited(name, true)
                }

                function inherited__debug(args, a1, a2) {
                    var f = this.getInherited(args, a1);
                    if (f) {
                        return f.apply(this, a2 || a1 || args)
                    }
                }
                var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

                function isInstanceOf(cls) {
                    var bases = this.constructor._meta.bases;
                    for (var i = 0, l = bases.length; i < l; ++i) {
                        if (bases[i] === cls) {
                            return true
                        }
                    }
                    return this instanceof cls
                }

                function mixOwn(target, source) {
                    for (var name in source) {
                        if (name != cname && source.hasOwnProperty(name)) {
                            target[name] = source[name]
                        }
                    }
                    if (has("bug-for-in-skips-shadowed")) {
                        for (var extraNames = lang._extraNames, i = extraNames.length; i;) {
                            name = extraNames[--i];
                            if (name != cname && source.hasOwnProperty(name)) {
                                target[name] = source[name]
                            }
                        }
                    }
                }

                function safeMixin(target, source) {
                    var name, t;
                    for (name in source) {
                        t = source[name];
                        if ((t !== op[name] || !(name in op)) && name != cname) {
                            if (opts.call(t) == "[object Function]") {
                                t.nom = name
                            }
                            target[name] = t
                        }
                    }
                    if (has("bug-for-in-skips-shadowed")) {
                        for (var extraNames = lang._extraNames, i = extraNames.length; i;) {
                            name = extraNames[--i];
                            t = source[name];
                            if ((t !== op[name] || !(name in op)) && name != cname) {
                                if (opts.call(t) == "[object Function]") {
                                    t.nom = name
                                }
                                target[name] = t
                            }
                        }
                    }
                    return target
                }

                function extend(source) {
                    declare.safeMixin(this.prototype, source);
                    return this
                }

                function createSubclass(mixins, props) {
                    if (!(mixins instanceof Array || typeof mixins == "function")) {
                        props = mixins;
                        mixins = undefined
                    }
                    props = props || {};
                    mixins = mixins || [];
                    return declare([this].concat(mixins), props)
                }

                function chainedConstructor(bases, ctorSpecial) {
                    return function() {
                        var a = arguments,
                            args = a,
                            a0 = a[0],
                            f, i, m, l = bases.length,
                            preArgs;
                        if (!(this instanceof a.callee)) {
                            return applyNew(a)
                        }
                        if (ctorSpecial && (a0 && a0.preamble || this.preamble)) {
                            preArgs = new Array(bases.length);
                            preArgs[0] = a;
                            for (i = 0;;) {
                                a0 = a[0];
                                if (a0) {
                                    f = a0.preamble;
                                    if (f) {
                                        a = f.apply(this, a) || a
                                    }
                                }
                                f = bases[i].prototype;
                                f = f.hasOwnProperty("preamble") && f.preamble;
                                if (f) {
                                    a = f.apply(this, a) || a
                                }
                                if (++i == l) {
                                    break
                                }
                                preArgs[i] = a
                            }
                        }
                        for (i = l - 1; i >= 0; --i) {
                            f = bases[i];
                            m = f._meta;
                            f = m ? m.ctor : f;
                            if (f) {
                                f.apply(this, preArgs ? preArgs[i] : a)
                            }
                        }
                        f = this.postscript;
                        if (f) {
                            f.apply(this, args)
                        }
                    }
                }

                function singleConstructor(ctor, ctorSpecial) {
                    return function() {
                        var a = arguments,
                            t = a,
                            a0 = a[0],
                            f;
                        if (!(this instanceof a.callee)) {
                            return applyNew(a)
                        }
                        if (ctorSpecial) {
                            if (a0) {
                                f = a0.preamble;
                                if (f) {
                                    t = f.apply(this, t) || t
                                }
                            }
                            f = this.preamble;
                            if (f) {
                                f.apply(this, t)
                            }
                        }
                        if (ctor) {
                            ctor.apply(this, a)
                        }
                        f = this.postscript;
                        if (f) {
                            f.apply(this, a)
                        }
                    }
                }

                function simpleConstructor(bases) {
                    return function() {
                        var a = arguments,
                            i = 0,
                            f, m;
                        if (!(this instanceof a.callee)) {
                            return applyNew(a)
                        }
                        for (; f = bases[i]; ++i) {
                            m = f._meta;
                            f = m ? m.ctor : f;
                            if (f) {
                                f.apply(this, a);
                                break
                            }
                        }
                        f = this.postscript;
                        if (f) {
                            f.apply(this, a)
                        }
                    }
                }

                function chain(name, bases, reversed) {
                    return function() {
                        var b, m, f, i = 0,
                            step = 1;
                        if (reversed) {
                            i = bases.length - 1;
                            step = -1
                        }
                        for (; b = bases[i]; i += step) {
                            m = b._meta;
                            f = (m ? m.hidden : b.prototype)[name];
                            if (f) {
                                f.apply(this, arguments)
                            }
                        }
                    }
                }

                function forceNew(ctor) {
                    xtor.prototype = ctor.prototype;
                    var t = new xtor;
                    xtor.prototype = null;
                    return t
                }

                function applyNew(args) {
                    var ctor = args.callee,
                        t = forceNew(ctor);
                    ctor.apply(t, args);
                    return t
                }

                function declare(className, superclass, props) {
                    if (typeof className != "string") {
                        props = superclass;
                        superclass = className;
                        className = ""
                    }
                    props = props || {};
                    var proto, i, t, ctor, name, bases, chains, mixins = 1,
                        parents = superclass;
                    if (opts.call(superclass) == "[object Array]") {
                        bases = c3mro(superclass, className);
                        t = bases[0];
                        mixins = bases.length - t;
                        superclass = bases[mixins]
                    } else {
                        bases = [0];
                        if (superclass) {
                            if (opts.call(superclass) == "[object Function]") {
                                t = superclass._meta;
                                bases = bases.concat(t ? t.bases : superclass)
                            } else {
                                err("base class is not a callable constructor.", className)
                            }
                        } else if (superclass !== null) {
                            err("unknown base class. Did you use dojo.require to pull it in?", className)
                        }
                    }
                    if (superclass) {
                        for (i = mixins - 1;; --i) {
                            proto = forceNew(superclass);
                            if (!i) {
                                break
                            }
                            t = bases[i];
                            (t._meta ? mixOwn : mix)(proto, t.prototype);
                            ctor = new Function;
                            ctor.superclass = superclass;
                            ctor.prototype = proto;
                            superclass = proto.constructor = ctor
                        }
                    } else {
                        proto = {}
                    }
                    declare.safeMixin(proto, props);
                    t = props.constructor;
                    if (t !== op.constructor) {
                        t.nom = cname;
                        proto.constructor = t
                    }
                    for (i = mixins - 1; i; --i) {
                        t = bases[i]._meta;
                        if (t && t.chains) {
                            chains = mix(chains || {}, t.chains)
                        }
                    }
                    if (proto["-chains-"]) {
                        chains = mix(chains || {}, proto["-chains-"])
                    }
                    t = !chains || !chains.hasOwnProperty(cname);
                    bases[0] = ctor = chains && chains.constructor === "manual" ? simpleConstructor(bases) : bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t);
                    ctor._meta = {
                        bases: bases,
                        hidden: props,
                        chains: chains,
                        parents: parents,
                        ctor: props.constructor
                    };
                    ctor.superclass = superclass && superclass.prototype;
                    ctor.extend = extend;
                    ctor.createSubclass = createSubclass;
                    ctor.prototype = proto;
                    proto.constructor = ctor;
                    proto.getInherited = getInherited;
                    proto.isInstanceOf = isInstanceOf;
                    proto.inherited = inheritedImpl;
                    proto.__inherited = inherited;
                    if (className) {
                        proto.declaredClass = className;
                        lang.setObject(className, ctor)
                    }
                    if (chains) {
                        for (name in chains) {
                            if (proto[name] && typeof chains[name] == "string" && name != cname) {
                                t = proto[name] = chain(name, bases, chains[name] === "after");
                                t.nom = name
                            }
                        }
                    }
                    return ctor
                }
                dojo.safeMixin = declare.safeMixin = safeMixin;
                dojo.declare = declare;
                return declare
            })
        },
        "dojo/_base/connect": function() {
            define(["./kernel", "../on", "../topic", "../aspect", "./event", "../mouse", "./sniff", "./lang", "../keys"], function(dojo, on, hub, aspect, eventModule, mouse, has, lang) {
                has.add("events-keypress-typed", function() {
                    var testKeyEvent = {
                        charCode: 0
                    };
                    try {
                        testKeyEvent = document.createEvent("KeyboardEvent");
                        (testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3)
                    } catch (e) {}
                    return testKeyEvent.charCode == 0 && !has("opera")
                });

                function connect_(obj, event, context, method, dontFix) {
                    method = lang.hitch(context, method);
                    if (!obj || !(obj.addEventListener || obj.attachEvent)) {
                        return aspect.after(obj || dojo.global, event, method, true)
                    }
                    if (typeof event == "string" && event.substring(0, 2) == "on") {
                        event = event.substring(2)
                    }
                    if (!obj) {
                        obj = dojo.global
                    }
                    if (!dontFix) {
                        switch (event) {
                            case "keypress":
                                event = keypress;
                                break;
                            case "mouseenter":
                                event = mouse.enter;
                                break;
                            case "mouseleave":
                                event = mouse.leave;
                                break
                        }
                    }
                    return on(obj, event, method, dontFix)
                }
                var _punctMap = {
                    106: 42,
                    111: 47,
                    186: 59,
                    187: 43,
                    188: 44,
                    189: 45,
                    190: 46,
                    191: 47,
                    192: 96,
                    219: 91,
                    220: 92,
                    221: 93,
                    222: 39,
                    229: 113
                };
                var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";
                var _synthesizeEvent = function(evt, props) {
                    var faux = lang.mixin({}, evt, props);
                    setKeyChar(faux);
                    faux.preventDefault = function() {
                        evt.preventDefault()
                    };
                    faux.stopPropagation = function() {
                        evt.stopPropagation()
                    };
                    return faux
                };

                function setKeyChar(evt) {
                    evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : "";
                    evt.charOrCode = evt.keyChar || evt.keyCode
                }
                var keypress;
                if (has("events-keypress-typed")) {
                    var _trySetKeyCode = function(e, code) {
                        try {
                            return e.keyCode = code
                        } catch (e) {
                            return 0
                        }
                    };
                    keypress = function(object, listener) {
                        var keydownSignal = on(object, "keydown", function(evt) {
                            var k = evt.keyCode;
                            var unprintable = k != 13 && k != 32 && (k != 27 || !has("ie")) && (k < 48 || k > 90) && (k < 96 || k > 111) && (k < 186 || k > 192) && (k < 219 || k > 222) && k != 229;
                            if (unprintable || evt.ctrlKey) {
                                var c = unprintable ? 0 : k;
                                if (evt.ctrlKey) {
                                    if (k == 3 || k == 13) {
                                        return listener.call(evt.currentTarget, evt)
                                    } else if (c > 95 && c < 106) {
                                        c -= 48
                                    } else if (!evt.shiftKey && (c >= 65 && c <= 90)) {
                                        c += 32
                                    } else {
                                        c = _punctMap[c] || c
                                    }
                                }
                                var faux = _synthesizeEvent(evt, {
                                    type: "keypress",
                                    faux: true,
                                    charCode: c
                                });
                                listener.call(evt.currentTarget, faux);
                                if (has("ie")) {
                                    _trySetKeyCode(evt, faux.keyCode)
                                }
                            }
                        });
                        var keypressSignal = on(object, "keypress", function(evt) {
                            var c = evt.charCode;
                            c = c >= 32 ? c : 0;
                            evt = _synthesizeEvent(evt, {
                                charCode: c,
                                faux: true
                            });
                            return listener.call(this, evt)
                        });
                        return {
                            remove: function() {
                                keydownSignal.remove();
                                keypressSignal.remove()
                            }
                        }
                    }
                } else {
                    if (has("opera")) {
                        keypress = function(object, listener) {
                            return on(object, "keypress", function(evt) {
                                var c = evt.which;
                                if (c == 3) {
                                    c = 99
                                }
                                c = c < 32 && !evt.shiftKey ? 0 : c;
                                if (evt.ctrlKey && !evt.shiftKey && c >= 65 && c <= 90) {
                                    c += 32
                                }
                                return listener.call(this, _synthesizeEvent(evt, {
                                    charCode: c
                                }))
                            })
                        }
                    } else {
                        keypress = function(object, listener) {
                            return on(object, "keypress", function(evt) {
                                setKeyChar(evt);
                                return listener.call(this, evt)
                            })
                        }
                    }
                }
                var connect = {
                    _keypress: keypress,
                    connect: function(obj, event, context, method, dontFix) {
                        var a = arguments,
                            args = [],
                            i = 0;
                        args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
                        var a1 = a[i + 1];
                        args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
                        for (var l = a.length; i < l; i++) {
                            args.push(a[i])
                        }
                        return connect_.apply(this, args)
                    },
                    disconnect: function(handle) {
                        if (handle) {
                            handle.remove()
                        }
                    },
                    subscribe: function(topic, context, method) {
                        return hub.subscribe(topic, lang.hitch(context, method))
                    },
                    publish: function(topic, args) {
                        return hub.publish.apply(hub, [topic].concat(args))
                    },
                    connectPublisher: function(topic, obj, event) {
                        var pf = function() {
                            connect.publish(topic, arguments)
                        };
                        return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf)
                    },
                    isCopyKey: function(e) {
                        return e[evtCopyKey]
                    }
                };
                connect.unsubscribe = connect.disconnect;
                1 && lang.mixin(dojo, connect);
                return connect
            })
        },
        "dojo/on": function() {
            define(["./has!dom-addeventlistener?:./aspect", "./_base/kernel", "./sniff"], function(aspect, dojo, has) {
                "use strict";
                if (1) {
                    var major = window.ScriptEngineMajorVersion;
                    has.add("jscript", major && major() + ScriptEngineMinorVersion() / 10);
                    has.add("event-orientationchange", has("touch") && !has("android"));
                    has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
                    has.add("event-focusin", function(global, doc, element) {
                        return "onfocusin" in element
                    });
                    if (has("touch")) {
                        has.add("touch-can-modify-event-delegate", function() {
                            var EventDelegate = function() {};
                            EventDelegate.prototype = document.createEvent("MouseEvents");
                            try {
                                var eventDelegate = new EventDelegate;
                                eventDelegate.target = null;
                                return eventDelegate.target === null
                            } catch (e) {
                                return false
                            }
                        })
                    }
                }
                var on = function(target, type, listener, dontFix) {
                    if (typeof target.on == "function" && typeof type != "function" && !target.nodeType) {
                        return target.on(type, listener)
                    }
                    return on.parse(target, type, listener, addListener, dontFix, this)
                };
                on.pausable = function(target, type, listener, dontFix) {
                    var paused;
                    var signal = on(target, type, function() {
                        if (!paused) {
                            return listener.apply(this, arguments)
                        }
                    }, dontFix);
                    signal.pause = function() {
                        paused = true
                    };
                    signal.resume = function() {
                        paused = false
                    };
                    return signal
                };
                on.once = function(target, type, listener, dontFix) {
                    var signal = on(target, type, function() {
                        signal.remove();
                        return listener.apply(this, arguments)
                    });
                    return signal
                };
                on.parse = function(target, type, listener, addListener, dontFix, matchesTarget) {
                    if (type.call) {
                        return type.call(matchesTarget, target, listener)
                    }
                    if (type instanceof Array) {
                        events = type
                    } else if (type.indexOf(",") > -1) {
                        var events = type.split(/\s*,\s*/)
                    }
                    if (events) {
                        var handles = [];
                        var i = 0;
                        var eventName;
                        while (eventName = events[i++]) {
                            handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget))
                        }
                        handles.remove = function() {
                            for (var i = 0; i < handles.length; i++) {
                                handles[i].remove()
                            }
                        };
                        return handles
                    }
                    return addListener(target, type, listener, dontFix, matchesTarget)
                };
                var touchEvents = /^touch/;

                function addListener(target, type, listener, dontFix, matchesTarget) {
                    var selector = type.match(/(.*):(.*)/);
                    if (selector) {
                        type = selector[2];
                        selector = selector[1];
                        return on.selector(selector, type).call(matchesTarget, target, listener)
                    }
                    if (has("touch")) {
                        if (touchEvents.test(type)) {
                            listener = fixTouchListener(listener)
                        }
                        if (!has("event-orientationchange") && type == "orientationchange") {
                            type = "resize";
                            target = window;
                            listener = fixTouchListener(listener)
                        }
                    }
                    if (addStopImmediate) {
                        listener = addStopImmediate(listener)
                    }
                    if (target.addEventListener) {
                        var capture = type in captures,
                            adjustedType = capture ? captures[type] : type;
                        target.addEventListener(adjustedType, listener, capture);
                        return {
                            remove: function() {
                                target.removeEventListener(adjustedType, listener, capture)
                            }
                        }
                    }
                    type = "on" + type;
                    if (fixAttach && target.attachEvent) {
                        return fixAttach(target, type, listener)
                    }
                    throw new Error("Target must be an event emitter")
                }
                on.matches = function(node, selector, context, children, matchesTarget) {
                    matchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;
                    children = children !== false;
                    if (node.nodeType != 1) {
                        node = node.parentNode
                    }
                    while (!matchesTarget.matches(node, selector, context)) {
                        if (node == context || children === false || !(node = node.parentNode) || node.nodeType != 1) {
                            return false
                        }
                    }
                    return node
                };
                on.selector = function(selector, eventType, children) {
                    return function(target, listener) {
                        var matchesTarget = typeof selector == "function" ? {
                                matches: selector
                            } : this,
                            bubble = eventType.bubble;

                        function select(eventTarget) {
                            return on.matches(eventTarget, selector, target, children, matchesTarget)
                        }
                        if (bubble) {
                            return on(target, bubble(select), listener)
                        }
                        return on(target, eventType, function(event) {
                            var eventTarget = select(event.target);
                            if (eventTarget) {
                                return listener.call(eventTarget, event)
                            }
                        })
                    }
                };

                function syntheticPreventDefault() {
                    this.cancelable = false;
                    this.defaultPrevented = true
                }

                function syntheticStopPropagation() {
                    this.bubbles = false
                }
                var slice = [].slice,
                    syntheticDispatch = on.emit = function(target, type, event) {
                        var args = slice.call(arguments, 2);
                        var method = "on" + type;
                        if ("parentNode" in target) {
                            var newEvent = args[0] = {};
                            for (var i in event) {
                                newEvent[i] = event[i]
                            }
                            newEvent.preventDefault = syntheticPreventDefault;
                            newEvent.stopPropagation = syntheticStopPropagation;
                            newEvent.target = target;
                            newEvent.type = type;
                            event = newEvent
                        }
                        do {
                            target[method] && target[method].apply(target, args)
                        } while (event && event.bubbles && (target = target.parentNode));
                        return event && event.cancelable && event
                    };
                var captures = has("event-focusin") ? {} : {
                    focusin: "focus",
                    focusout: "blur"
                };
                if (!has("event-stopimmediatepropagation")) {
                    var stopImmediatePropagation = function() {
                        this.immediatelyStopped = true;
                        this.modified = true
                    };
                    var addStopImmediate = function(listener) {
                        return function(event) {
                            if (!event.immediatelyStopped) {
                                event.stopImmediatePropagation = stopImmediatePropagation;
                                return listener.apply(this, arguments)
                            }
                        }
                    }
                }
                if (has("dom-addeventlistener")) {
                    on.emit = function(target, type, event) {
                        if (target.dispatchEvent && document.createEvent) {
                            var ownerDocument = target.ownerDocument || document;
                            var nativeEvent = ownerDocument.createEvent("HTMLEvents");
                            nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
                            for (var i in event) {
                                if (!(i in nativeEvent)) {
                                    nativeEvent[i] = event[i]
                                }
                            }
                            return target.dispatchEvent(nativeEvent) && nativeEvent
                        }
                        return syntheticDispatch.apply(on, arguments)
                    }
                } else {
                    on._fixEvent = function(evt, sender) {
                        if (!evt) {
                            var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
                            evt = w.event
                        }
                        if (!evt) {
                            return evt
                        }
                        try {
                            if (lastEvent && evt.type == lastEvent.type && evt.srcElement == lastEvent.target) {
                                evt = lastEvent
                            }
                        } catch (e) {}
                        if (!evt.target) {
                            evt.target = evt.srcElement;
                            evt.currentTarget = sender || evt.srcElement;
                            if (evt.type == "mouseover") {
                                evt.relatedTarget = evt.fromElement
                            }
                            if (evt.type == "mouseout") {
                                evt.relatedTarget = evt.toElement
                            }
                            if (!evt.stopPropagation) {
                                evt.stopPropagation = stopPropagation;
                                evt.preventDefault = preventDefault
                            }
                            switch (evt.type) {
                                case "keypress":
                                    var c = "charCode" in evt ? evt.charCode : evt.keyCode;
                                    if (c == 10) {
                                        c = 0;
                                        evt.keyCode = 13
                                    } else if (c == 13 || c == 27) {
                                        c = 0
                                    } else if (c == 3) {
                                        c = 99
                                    }
                                    evt.charCode = c;
                                    _setKeyChar(evt);
                                    break
                            }
                        }
                        return evt
                    };
                    var lastEvent, IESignal = function(handle) {
                        this.handle = handle
                    };
                    IESignal.prototype.remove = function() {
                        delete _dojoIEListeners_[this.handle]
                    };
                    var fixListener = function(listener) {
                        return function(evt) {
                            evt = on._fixEvent(evt, this);
                            var result = listener.call(this, evt);
                            if (evt.modified) {
                                if (!lastEvent) {
                                    setTimeout(function() {
                                        lastEvent = null
                                    })
                                }
                                lastEvent = evt
                            }
                            return result
                        }
                    };
                    var fixAttach = function(target, type, listener) {
                        listener = fixListener(listener);
                        if (((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || has("jscript") < 5.8) && !has("config-_allow_leaks")) {
                            if (typeof _dojoIEListeners_ == "undefined") {
                                _dojoIEListeners_ = []
                            }
                            var emitter = target[type];
                            if (!emitter || !emitter.listeners) {
                                var oldListener = emitter;
                                emitter = Function("event", "var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}");
                                emitter.listeners = [];
                                target[type] = emitter;
                                emitter.global = this;
                                if (oldListener) {
                                    emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1)
                                }
                            }
                            var handle;
                            emitter.listeners.push(handle = emitter.global._dojoIEListeners_.push(listener) - 1);
                            return new IESignal(handle)
                        }
                        return aspect.after(target, type, listener, true)
                    };
                    var _setKeyChar = function(evt) {
                        evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : "";
                        evt.charOrCode = evt.keyChar || evt.keyCode
                    };
                    var stopPropagation = function() {
                        this.cancelBubble = true
                    };
                    var preventDefault = on._preventDefault = function() {
                        this.bubbledKeyCode = this.keyCode;
                        if (this.ctrlKey) {
                            try {
                                this.keyCode = 0
                            } catch (e) {}
                        }
                        this.defaultPrevented = true;
                        this.returnValue = false;
                        this.modified = true
                    }
                }
                if (has("touch")) {
                    var EventDelegate = function() {};
                    var windowOrientation = window.orientation;
                    var fixTouchListener = function(listener) {
                        return function(originalEvent) {
                            var event = originalEvent.corrected;
                            if (!event) {
                                var type = originalEvent.type;
                                try {
                                    delete originalEvent.type
                                } catch (e) {}
                                if (originalEvent.type) {
                                    if (has("touch-can-modify-event-delegate")) {
                                        EventDelegate.prototype = originalEvent;
                                        event = new EventDelegate
                                    } else {
                                        event = {};
                                        for (var name in originalEvent) {
                                            event[name] = originalEvent[name]
                                        }
                                    }
                                    event.preventDefault = function() {
                                        originalEvent.preventDefault()
                                    };
                                    event.stopPropagation = function() {
                                        originalEvent.stopPropagation()
                                    }
                                } else {
                                    event = originalEvent;
                                    event.type = type
                                }
                                originalEvent.corrected = event;
                                if (type == "resize") {
                                    if (windowOrientation == window.orientation) {
                                        return null
                                    }
                                    windowOrientation = window.orientation;
                                    event.type = "orientationchange";
                                    return listener.call(this, event)
                                }
                                if (!("rotation" in event)) {
                                    event.rotation = 0;
                                    event.scale = 1
                                }
                                var firstChangeTouch = event.changedTouches[0];
                                for (var i in firstChangeTouch) {
                                    delete event[i];
                                    event[i] = firstChangeTouch[i]
                                }
                            }
                            return listener.call(this, event)
                        }
                    }
                }
                return on
            })
        },
        "dojo/topic": function() {
            define(["./Evented"], function(Evented) {
                var hub = new Evented;
                return {
                    publish: function(topic, event) {
                        return hub.emit.apply(hub, arguments)
                    },
                    subscribe: function(topic, listener) {
                        return hub.on.apply(hub, arguments)
                    }
                }
            })
        },
        "dojo/Evented": function() {
            define(["./aspect", "./on"], function(aspect, on) {
                "use strict";
                var after = aspect.after;

                function Evented() {}
                Evented.prototype = {
                    on: function(type, listener) {
                        return on.parse(this, type, listener, function(target, type) {
                            return after(target, "on" + type, listener, true)
                        })
                    },
                    emit: function(type, event) {
                        var args = [this];
                        args.push.apply(args, arguments);
                        return on.emit.apply(on, args)
                    }
                };
                return Evented
            })
        },
        "dojo/aspect": function() {
            define([], function() {
                "use strict";
                var undefined, nextId = 0;

                function advise(dispatcher, type, advice, receiveArguments) {
                    var previous = dispatcher[type];
                    var around = type == "around";
                    var signal;
                    if (around) {
                        var advised = advice(function() {
                            return previous.advice(this, arguments)
                        });
                        signal = {
                            remove: function() {
                                if (advised) {
                                    advised = dispatcher = advice = null
                                }
                            },
                            advice: function(target, args) {
                                return advised ? advised.apply(target, args) : previous.advice(target, args)
                            }
                        }
                    } else {
                        signal = {
                            remove: function() {
                                if (signal.advice) {
                                    var previous = signal.previous;
                                    var next = signal.next;
                                    if (!next && !previous) {
                                        delete dispatcher[type]
                                    } else {
                                        if (previous) {
                                            previous.next = next
                                        } else {
                                            dispatcher[type] = next
                                        }
                                        if (next) {
                                            next.previous = previous
                                        }
                                    }
                                    dispatcher = advice = signal.advice = null
                                }
                            },
                            id: nextId++,
                            advice: advice,
                            receiveArguments: receiveArguments
                        }
                    }
                    if (previous && !around) {
                        if (type == "after") {
                            while (previous.next && (previous = previous.next)) {}
                            previous.next = signal;
                            signal.previous = previous
                        } else if (type == "before") {
                            dispatcher[type] = signal;
                            signal.next = previous;
                            previous.previous = signal
                        }
                    } else {
                        dispatcher[type] = signal
                    }
                    return signal
                }

                function aspect(type) {
                    return function(target, methodName, advice, receiveArguments) {
                        var existing = target[methodName],
                            dispatcher;
                        if (!existing || existing.target != target) {
                            target[methodName] = dispatcher = function() {
                                var executionId = nextId;
                                var args = arguments;
                                var before = dispatcher.before;
                                while (before) {
                                    args = before.advice.apply(this, args) || args;
                                    before = before.next
                                }
                                if (dispatcher.around) {
                                    var results = dispatcher.around.advice(this, args)
                                }
                                var after = dispatcher.after;
                                while (after && after.id < executionId) {
                                    if (after.receiveArguments) {
                                        var newResults = after.advice.apply(this, args);
                                        results = newResults === undefined ? results : newResults
                                    } else {
                                        results = after.advice.call(this, results, args)
                                    }
                                    after = after.next
                                }
                                return results
                            };
                            if (existing) {
                                dispatcher.around = {
                                    advice: function(target, args) {
                                        return existing.apply(target, args)
                                    }
                                }
                            }
                            dispatcher.target = target
                        }
                        var results = advise(dispatcher || existing, type, advice, receiveArguments);
                        advice = null;
                        return results
                    }
                }
                var after = aspect("after");
                var before = aspect("before");
                var around = aspect("around");
                return {
                    before: before,
                    around: around,
                    after: after
                }
            })
        },
        "dojo/_base/event": function() {
            define(["./kernel", "../on", "../has", "../dom-geometry"], function(dojo, on, has, dom) {
                if (on._fixEvent) {
                    var fixEvent = on._fixEvent;
                    on._fixEvent = function(evt, se) {
                        evt = fixEvent(evt, se);
                        if (evt) {
                            dom.normalizeEvent(evt)
                        }
                        return evt
                    }
                }
                var ret = {
                    fix: function(evt, sender) {
                        if (on._fixEvent) {
                            return on._fixEvent(evt, sender)
                        }
                        return evt
                    },
                    stop: function(evt) {
                        if (has("dom-addeventlistener") || evt && evt.preventDefault) {
                            evt.preventDefault();
                            evt.stopPropagation()
                        } else {
                            evt = evt || window.event;
                            evt.cancelBubble = true;
                            on._preventDefault.call(evt)
                        }
                    }
                };
                if (1) {
                    dojo.fixEvent = ret.fix;
                    dojo.stopEvent = ret.stop
                }
                return ret
            })
        },
        "dojo/dom-geometry": function() {
            define(["./sniff", "./_base/window", "./dom", "./dom-style"], function(has, win, dom, style) {
                var geom = {};
                geom.boxModel = "content-box";
                if (has("ie")) {
                    geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box"
                }
                geom.getPadExtents = function getPadExtents(node, computedStyle) {
                    node = dom.byId(node);
                    var s = computedStyle || style.getComputedStyle(node),
                        px = style.toPixelValue,
                        l = px(node, s.paddingLeft),
                        t = px(node, s.paddingTop),
                        r = px(node, s.paddingRight),
                        b = px(node, s.paddingBottom);
                    return {
                        l: l,
                        t: t,
                        r: r,
                        b: b,
                        w: l + r,
                        h: t + b
                    }
                };
                var none = "none";
                geom.getBorderExtents = function getBorderExtents(node, computedStyle) {
                    node = dom.byId(node);
                    var px = style.toPixelValue,
                        s = computedStyle || style.getComputedStyle(node),
                        l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
                        t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
                        r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
                        b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
                    return {
                        l: l,
                        t: t,
                        r: r,
                        b: b,
                        w: l + r,
                        h: t + b
                    }
                };
                geom.getPadBorderExtents = function getPadBorderExtents(node, computedStyle) {
                    node = dom.byId(node);
                    var s = computedStyle || style.getComputedStyle(node),
                        p = geom.getPadExtents(node, s),
                        b = geom.getBorderExtents(node, s);
                    return {
                        l: p.l + b.l,
                        t: p.t + b.t,
                        r: p.r + b.r,
                        b: p.b + b.b,
                        w: p.w + b.w,
                        h: p.h + b.h
                    }
                };
                geom.getMarginExtents = function getMarginExtents(node, computedStyle) {
                    node = dom.byId(node);
                    var s = computedStyle || style.getComputedStyle(node),
                        px = style.toPixelValue,
                        l = px(node, s.marginLeft),
                        t = px(node, s.marginTop),
                        r = px(node, s.marginRight),
                        b = px(node, s.marginBottom);
                    return {
                        l: l,
                        t: t,
                        r: r,
                        b: b,
                        w: l + r,
                        h: t + b
                    }
                };
                geom.getMarginBox = function getMarginBox(node, computedStyle) {
                    node = dom.byId(node);
                    var s = computedStyle || style.getComputedStyle(node),
                        me = geom.getMarginExtents(node, s),
                        l = node.offsetLeft - me.l,
                        t = node.offsetTop - me.t,
                        p = node.parentNode,
                        px = style.toPixelValue,
                        pcs;
                    if (has("mozilla")) {
                        var sl = parseFloat(s.left),
                            st = parseFloat(s.top);
                        if (!isNaN(sl) && !isNaN(st)) {
                            l = sl;
                            t = st
                        } else {
                            if (p && p.style) {
                                pcs = style.getComputedStyle(p);
                                if (pcs.overflow != "visible") {
                                    l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
                                    t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0
                                }
                            }
                        }
                    } else if (has("opera") || has("ie") == 8 && !has("quirks")) {
                        if (p) {
                            pcs = style.getComputedStyle(p);
                            l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
                            t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0
                        }
                    }
                    return {
                        l: l,
                        t: t,
                        w: node.offsetWidth + me.w,
                        h: node.offsetHeight + me.h
                    }
                };
                geom.getContentBox = function getContentBox(node, computedStyle) {
                    node = dom.byId(node);
                    var s = computedStyle || style.getComputedStyle(node),
                        w = node.clientWidth,
                        h, pe = geom.getPadExtents(node, s),
                        be = geom.getBorderExtents(node, s);
                    if (!w) {
                        w = node.offsetWidth;
                        h = node.offsetHeight
                    } else {
                        h = node.clientHeight;
                        be.w = be.h = 0
                    }
                    if (has("opera")) {
                        pe.l += be.l;
                        pe.t += be.t
                    }
                    return {
                        l: pe.l,
                        t: pe.t,
                        w: w - pe.w - be.w,
                        h: h - pe.h - be.h
                    }
                };

                function setBox(node, l, t, w, h, u) {
                    u = u || "px";
                    var s = node.style;
                    if (!isNaN(l)) {
                        s.left = l + u
                    }
                    if (!isNaN(t)) {
                        s.top = t + u
                    }
                    if (w >= 0) {
                        s.width = w + u
                    }
                    if (h >= 0) {
                        s.height = h + u
                    }
                }

                function isButtonTag(node) {
                    return node.tagName.toLowerCase() == "button" || node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"
                }

                function usesBorderBox(node) {
                    return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node)
                }
                geom.setContentSize = function setContentSize(node, box, computedStyle) {
                    node = dom.byId(node);
                    var w = box.w,
                        h = box.h;
                    if (usesBorderBox(node)) {
                        var pb = geom.getPadBorderExtents(node, computedStyle);
                        if (w >= 0) {
                            w += pb.w
                        }
                        if (h >= 0) {
                            h += pb.h
                        }
                    }
                    setBox(node, NaN, NaN, w, h)
                };
                var nilExtents = {
                    l: 0,
                    t: 0,
                    w: 0,
                    h: 0
                };
                geom.setMarginBox = function setMarginBox(node, box, computedStyle) {
                    node = dom.byId(node);
                    var s = computedStyle || style.getComputedStyle(node),
                        w = box.w,
                        h = box.h,
                        pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
                        mb = geom.getMarginExtents(node, s);
                    if (has("webkit")) {
                        if (isButtonTag(node)) {
                            var ns = node.style;
                            if (w >= 0 && !ns.width) {
                                ns.width = "4px"
                            }
                            if (h >= 0 && !ns.height) {
                                ns.height = "4px"
                            }
                        }
                    }
                    if (w >= 0) {
                        w = Math.max(w - pb.w - mb.w, 0)
                    }
                    if (h >= 0) {
                        h = Math.max(h - pb.h - mb.h, 0)
                    }
                    setBox(node, box.l, box.t, w, h)
                };
                geom.isBodyLtr = function isBodyLtr(doc) {
                    doc = doc || win.doc;
                    return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"
                };
                geom.docScroll = function docScroll(doc) {
                    doc = doc || win.doc;
                    var node = win.doc.parentWindow || win.doc.defaultView;
                    return "pageXOffset" in node ? {
                        x: node.pageXOffset,
                        y: node.pageYOffset
                    } : (node = has("quirks") ? win.body(doc) : doc.documentElement) && {
                        x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc),
                        y: node.scrollTop || 0
                    }
                };
                if (has("ie")) {
                    geom.getIeDocumentElementOffset = function getIeDocumentElementOffset(doc) {
                        doc = doc || win.doc;
                        var de = doc.documentElement;
                        if (has("ie") < 8) {
                            var r = de.getBoundingClientRect(),
                                l = r.left,
                                t = r.top;
                            if (has("ie") < 7) {
                                l += de.clientLeft;
                                t += de.clientTop
                            }
                            return {
                                x: l < 0 ? 0 : l,
                                y: t < 0 ? 0 : t
                            }
                        } else {
                            return {
                                x: 0,
                                y: 0
                            }
                        }
                    }
                }
                geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(scrollLeft, doc) {
                    doc = doc || win.doc;
                    var ie = has("ie");
                    if (ie && !geom.isBodyLtr(doc)) {
                        var qk = has("quirks"),
                            de = qk ? win.body(doc) : doc.documentElement,
                            pwin = win.global;
                        if (ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight) {
                            scrollLeft += de.clientLeft
                        }
                        return ie < 8 || qk ? scrollLeft + de.clientWidth - de.scrollWidth : -scrollLeft
                    }
                    return scrollLeft
                };
                geom.position = function(node, includeScroll) {
                    node = dom.byId(node);
                    var db = win.body(node.ownerDocument),
                        ret = node.getBoundingClientRect();
                    ret = {
                        x: ret.left,
                        y: ret.top,
                        w: ret.right - ret.left,
                        h: ret.bottom - ret.top
                    };
                    if (has("ie") < 9) {
                        var offset = geom.getIeDocumentElementOffset(node.ownerDocument);
                        ret.x -= offset.x + (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
                        ret.y -= offset.y + (has("quirks") ? db.clientTop + db.offsetTop : 0)
                    }
                    if (includeScroll) {
                        var scroll = geom.docScroll(node.ownerDocument);
                        ret.x += scroll.x;
                        ret.y += scroll.y
                    }
                    return ret
                };
                geom.getMarginSize = function getMarginSize(node, computedStyle) {
                    node = dom.byId(node);
                    var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
                    var size = node.getBoundingClientRect();
                    return {
                        w: size.right - size.left + me.w,
                        h: size.bottom - size.top + me.h
                    }
                };
                geom.normalizeEvent = function(event) {
                    if (!("layerX" in event)) {
                        event.layerX = event.offsetX;
                        event.layerY = event.offsetY
                    }
                    if (!has("dom-addeventlistener")) {
                        var se = event.target;
                        var doc = se && se.ownerDocument || document;
                        var docBody = has("quirks") ? doc.body : doc.documentElement;
                        var offset = geom.getIeDocumentElementOffset(doc);
                        event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc) - offset.x;
                        event.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y
                    }
                };
                return geom
            })
        },
        "dojo/_base/window": function() {
            define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has) {
                var ret = {
                    global: dojo.global,
                    doc: dojo.global["document"] || null,
                    body: function(doc) {
                        doc = doc || dojo.doc;
                        return doc.body || doc.getElementsByTagName("body")[0]
                    },
                    setContext: function(globalObject, globalDocument) {
                        dojo.global = ret.global = globalObject;
                        dojo.doc = ret.doc = globalDocument
                    },
                    withGlobal: function(globalObject, callback, thisObject, cbArguments) {
                        var oldGlob = dojo.global;
                        try {
                            dojo.global = ret.global = globalObject;
                            return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments)
                        } finally {
                            dojo.global = ret.global = oldGlob
                        }
                    },
                    withDoc: function(documentObject, callback, thisObject, cbArguments) {
                        var oldDoc = ret.doc,
                            oldQ = has("quirks"),
                            oldIE = has("ie"),
                            isIE, mode, pwin;
                        try {
                            dojo.doc = ret.doc = documentObject;
                            dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true);
                            if (has("ie")) {
                                if ((pwin = documentObject.parentWindow) && pwin.navigator) {
                                    isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
                                    mode = documentObject.documentMode;
                                    if (mode && mode != 5 && Math.floor(isIE) != mode) {
                                        isIE = mode
                                    }
                                    dojo.isIE = has.add("ie", isIE, true, true)
                                }
                            }
                            if (thisObject && typeof callback == "string") {
                                callback = thisObject[callback]
                            }
                            return callback.apply(thisObject, cbArguments || [])
                        } finally {
                            dojo.doc = ret.doc = oldDoc;
                            dojo.isQuirks = has.add("quirks", oldQ, true, true);
                            dojo.isIE = has.add("ie", oldIE, true, true)
                        }
                    }
                };
                1 && lang.mixin(dojo, ret);
                return ret
            })
        },
        "dojo/dom": function() {
            define(["./sniff", "./_base/window"], function(has, win) {
                if (has("ie") <= 7) {
                    try {
                        document.execCommand("BackgroundImageCache", false, true)
                    } catch (e) {}
                }
                var dom = {};
                if (has("ie")) {
                    dom.byId = function(id, doc) {
                        if (typeof id != "string") {
                            return id
                        }
                        var _d = doc || win.doc,
                            te = id && _d.getElementById(id);
                        if (te && (te.attributes.id.value == id || te.id == id)) {
                            return te
                        } else {
                            var eles = _d.all[id];
                            if (!eles || eles.nodeName) {
                                eles = [eles]
                            }
                            var i = 0;
                            while (te = eles[i++]) {
                                if (te.attributes && te.attributes.id && te.attributes.id.value == id || te.id == id) {
                                    return te
                                }
                            }
                        }
                    }
                } else {
                    dom.byId = function(id, doc) {
                        return (typeof id == "string" ? (doc || win.doc).getElementById(id) : id) || null
                    }
                }
                dom.isDescendant = function(node, ancestor) {
                    try {
                        node = dom.byId(node);
                        ancestor = dom.byId(ancestor);
                        while (node) {
                            if (node == ancestor) {
                                return true
                            }
                            node = node.parentNode
                        }
                    } catch (e) {}
                    return false
                };
                has.add("css-user-select", function(global, doc, element) {
                    if (!element) {
                        return false
                    }
                    var style = element.style;
                    var prefixes = ["Khtml", "O", "Moz", "Webkit"],
                        i = prefixes.length,
                        name = "userSelect",
                        prefix;
                    do {
                        if (typeof style[name] !== "undefined") {
                            return name
                        }
                    } while (i-- && (name = prefixes[i] + "UserSelect"));
                    return false
                });
                var cssUserSelect = has("css-user-select");
                dom.setSelectable = cssUserSelect ? function(node, selectable) {
                    dom.byId(node).style[cssUserSelect] = selectable ? "" : "none"
                } : function(node, selectable) {
                    node = dom.byId(node);
                    var nodes = node.getElementsByTagName("*"),
                        i = nodes.length;
                    if (selectable) {
                        node.removeAttribute("unselectable");
                        while (i--) {
                            nodes[i].removeAttribute("unselectable")
                        }
                    } else {
                        node.setAttribute("unselectable", "on");
                        while (i--) {
                            nodes[i].setAttribute("unselectable", "on")
                        }
                    }
                };
                return dom
            })
        },
        "dojo/dom-style": function() {
            define(["./sniff", "./dom"], function(has, dom) {
                var getComputedStyle, style = {};
                if (has("webkit")) {
                    getComputedStyle = function(node) {
                        var s;
                        if (node.nodeType == 1) {
                            var dv = node.ownerDocument.defaultView;
                            s = dv.getComputedStyle(node, null);
                            if (!s && node.style) {
                                node.style.display = "";
                                s = dv.getComputedStyle(node, null)
                            }
                        }
                        return s || {}
                    }
                } else if (has("ie") && (has("ie") < 9 || has("quirks"))) {
                    getComputedStyle = function(node) {
                        return node.nodeType == 1 && node.currentStyle ? node.currentStyle : {}
                    }
                } else {
                    getComputedStyle = function(node) {
                        return node.nodeType == 1 ? node.ownerDocument.defaultView.getComputedStyle(node, null) : {}
                    }
                }
                style.getComputedStyle = getComputedStyle;
                var toPixel;
                if (!has("ie")) {
                    toPixel = function(element, value) {
                        return parseFloat(value) || 0
                    }
                } else {
                    toPixel = function(element, avalue) {
                        if (!avalue) {
                            return 0
                        }
                        if (avalue == "medium") {
                            return 4
                        }
                        if (avalue.slice && avalue.slice(-2) == "px") {
                            return parseFloat(avalue)
                        }
                        var s = element.style,
                            rs = element.runtimeStyle,
                            cs = element.currentStyle,
                            sLeft = s.left,
                            rsLeft = rs.left;
                        rs.left = cs.left;
                        try {
                            s.left = avalue;
                            avalue = s.pixelLeft
                        } catch (e) {
                            avalue = 0
                        }
                        s.left = sLeft;
                        rs.left = rsLeft;
                        return avalue
                    }
                }
                style.toPixelValue = toPixel;
                var astr = "DXImageTransform.Microsoft.Alpha";
                var af = function(n, f) {
                    try {
                        return n.filters.item(astr)
                    } catch (e) {
                        return f ? {} : null
                    }
                };
                var _getOpacity = has("ie") < 9 || has("ie") < 10 && has("quirks") ? function(node) {
                    try {
                        return af(node).Opacity / 100
                    } catch (e) {
                        return 1
                    }
                } : function(node) {
                    return getComputedStyle(node).opacity
                };
                var _setOpacity = has("ie") < 9 || has("ie") < 10 && has("quirks") ? function(node, opacity) {
                    if (opacity === "") {
                        opacity = 1
                    }
                    var ov = opacity * 100,
                        fullyOpaque = opacity === 1;
                    if (fullyOpaque) {
                        node.style.zoom = "";
                        if (af(node)) {
                            node.style.filter = node.style.filter.replace(new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "")
                        }
                    } else {
                        node.style.zoom = 1;
                        if (af(node)) {
                            af(node, 1).Opacity = ov
                        } else {
                            node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")"
                        }
                        af(node, 1).Enabled = true
                    }
                    if (node.tagName.toLowerCase() == "tr") {
                        for (var td = node.firstChild; td; td = td.nextSibling) {
                            if (td.tagName.toLowerCase() == "td") {
                                _setOpacity(td, opacity)
                            }
                        }
                    }
                    return opacity
                } : function(node, opacity) {
                    return node.style.opacity = opacity
                };
                var _pixelNamesCache = {
                    left: true,
                    top: true
                };
                var _pixelRegExp = /margin|padding|width|height|max|min|offset/;

                function _toStyleValue(node, type, value) {
                    type = type.toLowerCase();
                    if (has("ie") || has("trident")) {
                        if (value == "auto") {
                            if (type == "height") {
                                return node.offsetHeight
                            }
                            if (type == "width") {
                                return node.offsetWidth
                            }
                        }
                        if (type == "fontweight") {
                            switch (value) {
                                case 700:
                                    return "bold";
                                case 400:
                                default:
                                    return "normal"
                            }
                        }
                    }
                    if (!(type in _pixelNamesCache)) {
                        _pixelNamesCache[type] = _pixelRegExp.test(type)
                    }
                    return _pixelNamesCache[type] ? toPixel(node, value) : value
                }
                var _floatAliases = {
                    cssFloat: 1,
                    styleFloat: 1,
                    "float": 1
                };
                style.get = function getStyle(node, name) {
                    var n = dom.byId(node),
                        l = arguments.length,
                        op = name == "opacity";
                    if (l == 2 && op) {
                        return _getOpacity(n)
                    }
                    name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
                    var s = style.getComputedStyle(n);
                    return l == 1 ? s : _toStyleValue(n, name, s[name] || n.style[name])
                };
                style.set = function setStyle(node, name, value) {
                    var n = dom.byId(node),
                        l = arguments.length,
                        op = name == "opacity";
                    name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
                    if (l == 3) {
                        return op ? _setOpacity(n, value) : n.style[name] = value
                    }
                    for (var x in name) {
                        style.set(node, x, name[x])
                    }
                    return style.getComputedStyle(n)
                };
                return style
            })
        },
        "dojo/mouse": function() {
            define(["./_base/kernel", "./on", "./has", "./dom", "./_base/window"], function(dojo, on, has, dom, win) {
                has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
                has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
                has.add("events-mousewheel", win.doc && "onmousewheel" in win.doc);
                var mouseButtons;
                if (has("dom-quirks") && has("ie") || !has("dom-addeventlistener")) {
                    mouseButtons = {
                        LEFT: 1,
                        MIDDLE: 4,
                        RIGHT: 2,
                        isButton: function(e, button) {
                            return e.button & button
                        },
                        isLeft: function(e) {
                            return e.button & 1
                        },
                        isMiddle: function(e) {
                            return e.button & 4
                        },
                        isRight: function(e) {
                            return e.button & 2
                        }
                    }
                } else {
                    mouseButtons = {
                        LEFT: 0,
                        MIDDLE: 1,
                        RIGHT: 2,
                        isButton: function(e, button) {
                            return e.button == button
                        },
                        isLeft: function(e) {
                            return e.button == 0
                        },
                        isMiddle: function(e) {
                            return e.button == 1
                        },
                        isRight: function(e) {
                            return e.button == 2
                        }
                    }
                }
                dojo.mouseButtons = mouseButtons;

                function eventHandler(type, selectHandler) {
                    var handler = function(node, listener) {
                        return on(node, type, function(evt) {
                            if (selectHandler) {
                                return selectHandler(evt, listener)
                            }
                            if (!dom.isDescendant(evt.relatedTarget, node)) {
                                return listener.call(this, evt)
                            }
                        })
                    };
                    handler.bubble = function(select) {
                        return eventHandler(type, function(evt, listener) {
                            var target = select(evt.target);
                            var relatedTarget = evt.relatedTarget;
                            if (target && target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget))) {
                                return listener.call(target, evt)
                            }
                        })
                    };
                    return handler
                }
                var wheel;
                if (has("events-mousewheel")) {
                    wheel = "mousewheel"
                } else {
                    wheel = function(node, listener) {
                        return on(node, "DOMMouseScroll", function(evt) {
                            evt.wheelDelta = -evt.detail;
                            listener.call(this, evt)
                        })
                    }
                }
                return {
                    _eventHandler: eventHandler,
                    enter: eventHandler("mouseover"),
                    leave: eventHandler("mouseout"),
                    wheel: wheel,
                    isLeft: mouseButtons.isLeft,
                    isMiddle: mouseButtons.isMiddle,
                    isRight: mouseButtons.isRight
                }
            })
        },
        "dojo/_base/sniff": function() {
            define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has) {
                if (!1) {
                    return has
                }
                dojo._name = "browser";
                lang.mixin(dojo, {
                    isBrowser: true,
                    isFF: has("ff"),
                    isIE: has("ie"),
                    isKhtml: has("khtml"),
                    isWebKit: has("webkit"),
                    isMozilla: has("mozilla"),
                    isMoz: has("mozilla"),
                    isOpera: has("opera"),
                    isSafari: has("safari"),
                    isChrome: has("chrome"),
                    isMac: has("mac"),
                    isIos: has("ios"),
                    isAndroid: has("android"),
                    isWii: has("wii"),
                    isQuirks: has("quirks"),
                    isAir: has("air")
                });
                return has
            })
        },
        "dojo/keys": function() {
            define(["./_base/kernel", "./sniff"], function(dojo, has) {
                return dojo.keys = {
                    BACKSPACE: 8,
                    TAB: 9,
                    CLEAR: 12,
                    ENTER: 13,
                    SHIFT: 16,
                    CTRL: 17,
                    ALT: 18,
                    META: has("webkit") ? 91 : 224,
                    PAUSE: 19,
                    CAPS_LOCK: 20,
                    ESCAPE: 27,
                    SPACE: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT_ARROW: 37,
                    UP_ARROW: 38,
                    RIGHT_ARROW: 39,
                    DOWN_ARROW: 40,
                    INSERT: 45,
                    DELETE: 46,
                    HELP: 47,
                    LEFT_WINDOW: 91,
                    RIGHT_WINDOW: 92,
                    SELECT: 93,
                    NUMPAD_0: 96,
                    NUMPAD_1: 97,
                    NUMPAD_2: 98,
                    NUMPAD_3: 99,
                    NUMPAD_4: 100,
                    NUMPAD_5: 101,
                    NUMPAD_6: 102,
                    NUMPAD_7: 103,
                    NUMPAD_8: 104,
                    NUMPAD_9: 105,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_PLUS: 107,
                    NUMPAD_ENTER: 108,
                    NUMPAD_MINUS: 109,
                    NUMPAD_PERIOD: 110,
                    NUMPAD_DIVIDE: 111,
                    F1: 112,
                    F2: 113,
                    F3: 114,
                    F4: 115,
                    F5: 116,
                    F6: 117,
                    F7: 118,
                    F8: 119,
                    F9: 120,
                    F10: 121,
                    F11: 122,
                    F12: 123,
                    F13: 124,
                    F14: 125,
                    F15: 126,
                    NUM_LOCK: 144,
                    SCROLL_LOCK: 145,
                    UP_DPAD: 175,
                    DOWN_DPAD: 176,
                    LEFT_DPAD: 177,
                    RIGHT_DPAD: 178,
                    copyKey: has("mac") && !has("air") ? has("safari") ? 91 : 224 : 17
                }
            })
        },
        "dojo/_base/Deferred": function() {
            define(["./kernel", "../Deferred", "../promise/Promise", "../errors/CancelError", "../has", "./lang", "../when"], function(dojo, NewDeferred, Promise, CancelError, has, lang, when) {
                var mutator = function() {};
                var freeze = Object.freeze || function() {};
                var Deferred = dojo.Deferred = function(canceller) {
                    var result, finished, canceled, fired, isError, head, nextListener;
                    var promise = this.promise = new Promise;

                    function complete(value) {
                        if (finished) {
                            throw new Error("This deferred has already been resolved")
                        }
                        result = value;
                        finished = true;
                        notify()
                    }

                    function notify() {
                        var mutated;
                        while (!mutated && nextListener) {
                            var listener = nextListener;
                            nextListener = nextListener.next;
                            if (mutated = listener.progress == mutator) {
                                finished = false
                            }
                            var func = isError ? listener.error : listener.resolved;
                            if (has("config-useDeferredInstrumentation")) {
                                if (isError && NewDeferred.instrumentRejected) {
                                    NewDeferred.instrumentRejected(result, !!func)
                                }
                            }
                            if (func) {
                                try {
                                    var newResult = func(result);
                                    if (newResult && typeof newResult.then === "function") {
                                        newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
                                        continue
                                    }
                                    var unchanged = mutated && newResult === undefined;
                                    if (mutated && !unchanged) {
                                        isError = newResult instanceof Error
                                    }
                                    listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult)
                                } catch (e) {
                                    listener.deferred.reject(e)
                                }
                            } else {
                                if (isError) {
                                    listener.deferred.reject(result)
                                } else {
                                    listener.deferred.resolve(result)
                                }
                            }
                        }
                    }
                    this.isResolved = promise.isResolved = function() {
                        return fired == 0
                    };
                    this.isRejected = promise.isRejected = function() {
                        return fired == 1
                    };
                    this.isFulfilled = promise.isFulfilled = function() {
                        return fired >= 0
                    };
                    this.isCanceled = promise.isCanceled = function() {
                        return canceled
                    };
                    this.resolve = this.callback = function(value) {
                        this.fired = fired = 0;
                        this.results = [value, null];
                        complete(value)
                    };
                    this.reject = this.errback = function(error) {
                        isError = true;
                        this.fired = fired = 1;
                        if (has("config-useDeferredInstrumentation")) {
                            if (NewDeferred.instrumentRejected) {
                                NewDeferred.instrumentRejected(error, !!nextListener)
                            }
                        }
                        complete(error);
                        this.results = [null, error]
                    };
                    this.progress = function(update) {
                        var listener = nextListener;
                        while (listener) {
                            var progress = listener.progress;
                            progress && progress(update);
                            listener = listener.next
                        }
                    };
                    this.addCallbacks = function(callback, errback) {
                        this.then(callback, errback, mutator);
                        return this
                    };
                    promise.then = this.then = function(resolvedCallback, errorCallback, progressCallback) {
                        var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
                        var listener = {
                            resolved: resolvedCallback,
                            error: errorCallback,
                            progress: progressCallback,
                            deferred: returnDeferred
                        };
                        if (nextListener) {
                            head = head.next = listener
                        } else {
                            nextListener = head = listener
                        }
                        if (finished) {
                            notify()
                        }
                        return returnDeferred.promise
                    };
                    var deferred = this;
                    promise.cancel = this.cancel = function() {
                        if (!finished) {
                            var error = canceller && canceller(deferred);
                            if (!finished) {
                                if (!(error instanceof Error)) {
                                    error = new CancelError(error)
                                }
                                error.log = false;
                                deferred.reject(error)
                            }
                        }
                        canceled = true
                    };
                    freeze(promise)
                };
                lang.extend(Deferred, {
                    addCallback: function(callback) {
                        return this.addCallbacks(lang.hitch.apply(dojo, arguments))
                    },
                    addErrback: function(errback) {
                        return this.addCallbacks(null, lang.hitch.apply(dojo, arguments))
                    },
                    addBoth: function(callback) {
                        var enclosed = lang.hitch.apply(dojo, arguments);
                        return this.addCallbacks(enclosed, enclosed)
                    },
                    fired: -1
                });
                Deferred.when = dojo.when = when;
                return Deferred
            })
        },
        "dojo/Deferred": function() {
            define(["./has", "./_base/lang", "./errors/CancelError", "./promise/Promise", "./promise/instrumentation"], function(has, lang, CancelError, Promise, instrumentation) {
                "use strict";
                var PROGRESS = 0,
                    RESOLVED = 1,
                    REJECTED = 2;
                var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";
                var freezeObject = Object.freeze || function() {};
                var signalWaiting = function(waiting, type, result, rejection, deferred) {
                    if (1) {
                        if (type === REJECTED && Deferred.instrumentRejected && waiting.length === 0) {
                            Deferred.instrumentRejected(result, false, rejection, deferred)
                        }
                    }
                    for (var i = 0; i < waiting.length; i++) {
                        signalListener(waiting[i], type, result, rejection)
                    }
                };
                var signalListener = function(listener, type, result, rejection) {
                    var func = listener[type];
                    var deferred = listener.deferred;
                    if (func) {
                        try {
                            var newResult = func(result);
                            if (type === PROGRESS) {
                                if (typeof newResult !== "undefined") {
                                    signalDeferred(deferred, type, newResult)
                                }
                            } else {
                                if (newResult && typeof newResult.then === "function") {
                                    listener.cancel = newResult.cancel;
                                    newResult.then(makeDeferredSignaler(deferred, RESOLVED), makeDeferredSignaler(deferred, REJECTED), makeDeferredSignaler(deferred, PROGRESS));
                                    return
                                }
                                signalDeferred(deferred, RESOLVED, newResult)
                            }
                        } catch (error) {
                            signalDeferred(deferred, REJECTED, error)
                        }
                    } else {
                        signalDeferred(deferred, type, result)
                    }
                    if (1) {
                        if (type === REJECTED && Deferred.instrumentRejected) {
                            Deferred.instrumentRejected(result, !!func, rejection, deferred.promise)
                        }
                    }
                };
                var makeDeferredSignaler = function(deferred, type) {
                    return function(value) {
                        signalDeferred(deferred, type, value)
                    }
                };
                var signalDeferred = function(deferred, type, result) {
                    if (!deferred.isCanceled()) {
                        switch (type) {
                            case PROGRESS:
                                deferred.progress(result);
                                break;
                            case RESOLVED:
                                deferred.resolve(result);
                                break;
                            case REJECTED:
                                deferred.reject(result);
                                break
                        }
                    }
                };
                var Deferred = function(canceler) {
                    var promise = this.promise = new Promise;
                    var deferred = this;
                    var fulfilled, result, rejection;
                    var canceled = false;
                    var waiting = [];
                    if (1 && Error.captureStackTrace) {
                        Error.captureStackTrace(deferred, Deferred);
                        Error.captureStackTrace(promise, Deferred)
                    }
                    this.isResolved = promise.isResolved = function() {
                        return fulfilled === RESOLVED
                    };
                    this.isRejected = promise.isRejected = function() {
                        return fulfilled === REJECTED
                    };
                    this.isFulfilled = promise.isFulfilled = function() {
                        return !!fulfilled
                    };
                    this.isCanceled = promise.isCanceled = function() {
                        return canceled
                    };
                    this.progress = function(update, strict) {
                        if (!fulfilled) {
                            signalWaiting(waiting, PROGRESS, update, null, deferred);
                            return promise
                        } else if (strict === true) {
                            throw new Error(FULFILLED_ERROR_MESSAGE)
                        } else {
                            return promise
                        }
                    };
                    this.resolve = function(value, strict) {
                        if (!fulfilled) {
                            signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
                            waiting = null;
                            return promise
                        } else if (strict === true) {
                            throw new Error(FULFILLED_ERROR_MESSAGE)
                        } else {
                            return promise
                        }
                    };
                    var reject = this.reject = function(error, strict) {
                        if (!fulfilled) {
                            if (1 && Error.captureStackTrace) {
                                Error.captureStackTrace(rejection = {}, reject)
                            }
                            signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
                            waiting = null;
                            return promise
                        } else if (strict === true) {
                            throw new Error(FULFILLED_ERROR_MESSAGE)
                        } else {
                            return promise
                        }
                    };
                    this.then = promise.then = function(callback, errback, progback) {
                        var listener = [progback, callback, errback];
                        listener.cancel = promise.cancel;
                        listener.deferred = new Deferred(function(reason) {
                            return listener.cancel && listener.cancel(reason)
                        });
                        if (fulfilled && !waiting) {
                            signalListener(listener, fulfilled, result, rejection)
                        } else {
                            waiting.push(listener)
                        }
                        return listener.deferred.promise
                    };
                    this.cancel = promise.cancel = function(reason, strict) {
                        if (!fulfilled) {
                            if (canceler) {
                                var returnedReason = canceler(reason);
                                reason = typeof returnedReason === "undefined" ? reason : returnedReason
                            }
                            canceled = true;
                            if (!fulfilled) {
                                if (typeof reason === "undefined") {
                                    reason = new CancelError
                                }
                                reject(reason);
                                return reason
                            } else if (fulfilled === REJECTED && result === reason) {
                                return reason
                            }
                        } else if (strict === true) {
                            throw new Error(FULFILLED_ERROR_MESSAGE)
                        }
                    };
                    freezeObject(promise)
                };
                Deferred.prototype.toString = function() {
                    return "[object Deferred]"
                };
                if (instrumentation) {
                    instrumentation(Deferred)
                }
                return Deferred
            })
        },
        "dojo/errors/CancelError": function() {
            define(["./create"], function(create) {
                return create("CancelError", null, null, {
                    dojoType: "cancel"
                })
            })
        },
        "dojo/errors/create": function() {
            define(["../_base/lang"], function(lang) {
                return function(name, ctor, base, props) {
                    base = base || Error;
                    var ErrorCtor = function(message) {
                        if (base === Error) {
                            if (Error.captureStackTrace) {
                                Error.captureStackTrace(this, ErrorCtor)
                            }
                            var err = Error.call(this, message),
                                prop;
                            for (prop in err) {
                                if (err.hasOwnProperty(prop)) {
                                    this[prop] = err[prop]
                                }
                            }
                            this.message = message;
                            this.stack = err.stack
                        } else {
                            base.apply(this, arguments)
                        }
                        if (ctor) {
                            ctor.apply(this, arguments)
                        }
                    };
                    ErrorCtor.prototype = lang.delegate(base.prototype, props);
                    ErrorCtor.prototype.name = name;
                    ErrorCtor.prototype.constructor = ErrorCtor;
                    return ErrorCtor
                }
            })
        },
        "dojo/promise/Promise": function() {
            define(["../_base/lang"], function(lang) {
                "use strict";

                function throwAbstract() {
                    throw new TypeError("abstract")
                }
                return lang.extend(function Promise() {}, {
                    then: function(callback, errback, progback) {
                        throwAbstract()
                    },
                    cancel: function(reason, strict) {
                        throwAbstract()
                    },
                    isResolved: function() {
                        throwAbstract()
                    },
                    isRejected: function() {
                        throwAbstract()
                    },
                    isFulfilled: function() {
                        throwAbstract()
                    },
                    isCanceled: function() {
                        throwAbstract()
                    },
                    always: function(callbackOrErrback) {
                        return this.then(callbackOrErrback, callbackOrErrback)
                    },
                    otherwise: function(errback) {
                        return this.then(null, errback)
                    },
                    trace: function() {
                        return this
                    },
                    traceRejected: function() {
                        return this
                    },
                    toString: function() {
                        return "[object Promise]"
                    }
                })
            })
        },
        "dojo/promise/instrumentation": function() {
            define(["./tracer", "../has", "../_base/lang", "../_base/array"], function(tracer, has, lang, arrayUtil) {
                has.add("config-useDeferredInstrumentation", "report-unhandled-rejections");

                function logError(error, rejection, deferred) {
                    var stack = "";
                    if (error && error.stack) {
                        stack += error.stack
                    }
                    if (rejection && rejection.stack) {
                        stack += "\n    ----------------------------------------\n    rejected" + rejection.stack.split("\n").slice(1).join("\n").replace(/^\s+/, " ")
                    }
                    if (deferred && deferred.stack) {
                        stack += "\n    ----------------------------------------\n" + deferred.stack
                    }
                    console.error(error, stack)
                }

                function reportRejections(error, handled, rejection, deferred) {
                    if (!handled) {
                        logError(error, rejection, deferred)
                    }
                }
                var errors = [];
                var activeTimeout = false;
                var unhandledWait = 1e3;

                function trackUnhandledRejections(error, handled, rejection, deferred) {
                    if (!arrayUtil.some(errors, function(obj) {
                            if (obj.error === error) {
                                if (handled) {
                                    obj.handled = true
                                }
                                return true
                            }
                        })) {
                        errors.push({
                            error: error,
                            rejection: rejection,
                            handled: handled,
                            deferred: deferred,
                            timestamp: (new Date).getTime()
                        })
                    }
                    if (!activeTimeout) {
                        activeTimeout = setTimeout(logRejected, unhandledWait)
                    }
                }

                function logRejected() {
                    var now = (new Date).getTime();
                    var reportBefore = now - unhandledWait;
                    errors = arrayUtil.filter(errors, function(obj) {
                        if (obj.timestamp < reportBefore) {
                            if (!obj.handled) {
                                logError(obj.error, obj.rejection, obj.deferred)
                            }
                            return false
                        }
                        return true
                    });
                    if (errors.length) {
                        activeTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now)
                    } else {
                        activeTimeout = false
                    }
                }
                return function(Deferred) {
                    var usage = has("config-useDeferredInstrumentation");
                    if (usage) {
                        tracer.on("resolved", lang.hitch(console, "log", "resolved"));
                        tracer.on("rejected", lang.hitch(console, "log", "rejected"));
                        tracer.on("progress", lang.hitch(console, "log", "progress"));
                        var args = [];
                        if (typeof usage === "string") {
                            args = usage.split(",");
                            usage = args.shift()
                        }
                        if (usage === "report-rejections") {
                            Deferred.instrumentRejected = reportRejections
                        } else if (usage === "report-unhandled-rejections" || usage === true || usage === 1) {
                            Deferred.instrumentRejected = trackUnhandledRejections;
                            unhandledWait = parseInt(args[0], 10) || unhandledWait
                        } else {
                            throw new Error("Unsupported instrumentation usage <" + usage + ">")
                        }
                    }
                }
            })
        },
        "dojo/promise/tracer": function() {
            define(["../_base/lang", "./Promise", "../Evented"], function(lang, Promise, Evented) {
                "use strict";
                var evented = new Evented;
                var emit = evented.emit;
                evented.emit = null;

                function emitAsync(args) {
                    setTimeout(function() {
                        emit.apply(evented, args)
                    }, 0)
                }
                Promise.prototype.trace = function() {
                    var args = lang._toArray(arguments);
                    this.then(function(value) {
                        emitAsync(["resolved", value].concat(args))
                    }, function(error) {
                        emitAsync(["rejected", error].concat(args))
                    }, function(update) {
                        emitAsync(["progress", update].concat(args))
                    });
                    return this
                };
                Promise.prototype.traceRejected = function() {
                    var args = lang._toArray(arguments);
                    this.otherwise(function(error) {
                        emitAsync(["rejected", error].concat(args))
                    });
                    return this
                };
                return evented
            })
        },
        "dojo/when": function() {
            define(["./Deferred", "./promise/Promise"], function(Deferred, Promise) {
                "use strict";
                return function when(valueOrPromise, callback, errback, progback) {
                    var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
                    var nativePromise = receivedPromise && valueOrPromise instanceof Promise;
                    if (!receivedPromise) {
                        if (arguments.length > 1) {
                            return callback ? callback(valueOrPromise) : valueOrPromise
                        } else {
                            return (new Deferred).resolve(valueOrPromise)
                        }
                    } else if (!nativePromise) {
                        var deferred = new Deferred(valueOrPromise.cancel);
                        valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
                        valueOrPromise = deferred.promise
                    }
                    if (callback || errback || progback) {
                        return valueOrPromise.then(callback, errback, progback)
                    }
                    return valueOrPromise
                }
            })
        },
        "dojo/_base/json": function() {
            define(["./kernel", "../json"], function(dojo, json) {
                dojo.fromJson = function(js) {
                    return eval("(" + js + ")")
                };
                dojo._escapeString = json.stringify;
                dojo.toJsonIndentStr = "	";
                dojo.toJson = function(it, prettyPrint) {
                    return json.stringify(it, function(key, value) {
                        if (value) {
                            var tf = value.__json__ || value.json;
                            if (typeof tf == "function") {
                                return tf.call(value)
                            }
                        }
                        return value
                    }, prettyPrint && dojo.toJsonIndentStr)
                };
                return dojo
            })
        },
        "dojo/json": function() {
            define(["./has"], function(has) {
                "use strict";
                var hasJSON = typeof JSON != "undefined";
                has.add("json-parse", hasJSON);
                has.add("json-stringify", hasJSON && JSON.stringify({
                    a: 0
                }, function(k, v) {
                    return v || 1
                }) == '{"a":1}');
                if (has("json-stringify")) {
                    return JSON
                } else {
                    var escapeString = function(str) {
                        return ('"' + str.replace(/(["\\])/g, "\\$1") + '"').replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r")
                    };
                    return {
                        parse: has("json-parse") ? JSON.parse : function(str, strict) {
                            if (strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)) {
                                throw new SyntaxError("Invalid characters in JSON")
                            }
                            return eval("(" + str + ")")
                        },
                        stringify: function(value, replacer, spacer) {
                            var undef;
                            if (typeof replacer == "string") {
                                spacer = replacer;
                                replacer = null
                            }

                            function stringify(it, indent, key) {
                                if (replacer) {
                                    it = replacer(key, it)
                                }
                                var val, objtype = typeof it;
                                if (objtype == "number") {
                                    return isFinite(it) ? it + "" : "null"
                                }
                                if (objtype == "boolean") {
                                    return it + ""
                                }
                                if (it === null) {
                                    return "null"
                                }
                                if (typeof it == "string") {
                                    return escapeString(it)
                                }
                                if (objtype == "function" || objtype == "undefined") {
                                    return undef
                                }
                                if (typeof it.toJSON == "function") {
                                    return stringify(it.toJSON(key), indent, key)
                                }
                                if (it instanceof Date) {
                                    return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus) {
                                        var num = it["getUTC" + prop]() + (plus ? 1 : 0);
                                        return num < 10 ? "0" + num : num
                                    })
                                }
                                if (it.valueOf() !== it) {
                                    return stringify(it.valueOf(), indent, key)
                                }
                                var nextIndent = spacer ? indent + spacer : "";
                                var sep = spacer ? " " : "";
                                var newLine = spacer ? "\n" : "";
                                if (it instanceof Array) {
                                    var itl = it.length,
                                        res = [];
                                    for (key = 0; key < itl; key++) {
                                        var obj = it[key];
                                        val = stringify(obj, nextIndent, key);
                                        if (typeof val != "string") {
                                            val = "null"
                                        }
                                        res.push(newLine + nextIndent + val)
                                    }
                                    return "[" + res.join(",") + newLine + indent + "]"
                                }
                                var output = [];
                                for (key in it) {
                                    var keyStr;
                                    if (it.hasOwnProperty(key)) {
                                        if (typeof key == "number") {
                                            keyStr = '"' + key + '"'
                                        } else if (typeof key == "string") {
                                            keyStr = escapeString(key)
                                        } else {
                                            continue
                                        }
                                        val = stringify(it[key], nextIndent, key);
                                        if (typeof val != "string") {
                                            continue
                                        }
                                        output.push(newLine + nextIndent + keyStr + ":" + sep + val)
                                    }
                                }
                                return "{" + output.join(",") + newLine + indent + "}"
                            }
                            return stringify(value, "", "")
                        }
                    }
                }
            })
        },
        "dojo/_base/Color": function() {
            define(["./kernel", "./lang", "./array", "./config"], function(dojo, lang, ArrayUtil, config) {
                var Color = dojo.Color = function(color) {
                    if (color) {
                        this.setColor(color)
                    }
                };
                Color.named = {
                    black: [0, 0, 0],
                    silver: [192, 192, 192],
                    gray: [128, 128, 128],
                    white: [255, 255, 255],
                    maroon: [128, 0, 0],
                    red: [255, 0, 0],
                    purple: [128, 0, 128],
                    fuchsia: [255, 0, 255],
                    green: [0, 128, 0],
                    lime: [0, 255, 0],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    navy: [0, 0, 128],
                    blue: [0, 0, 255],
                    teal: [0, 128, 128],
                    aqua: [0, 255, 255],
                    transparent: config.transparentColor || [0, 0, 0, 0]
                };
                lang.extend(Color, {
                    r: 255,
                    g: 255,
                    b: 255,
                    a: 1,
                    _set: function(r, g, b, a) {
                        var t = this;
                        t.r = r;
                        t.g = g;
                        t.b = b;
                        t.a = a
                    },
                    setColor: function(color) {
                        if (lang.isString(color)) {
                            Color.fromString(color, this)
                        } else if (lang.isArray(color)) {
                            Color.fromArray(color, this)
                        } else {
                            this._set(color.r, color.g, color.b, color.a);
                            if (!(color instanceof Color)) {
                                this.sanitize()
                            }
                        }
                        return this
                    },
                    sanitize: function() {
                        return this
                    },
                    toRgb: function() {
                        var t = this;
                        return [t.r, t.g, t.b]
                    },
                    toRgba: function() {
                        var t = this;
                        return [t.r, t.g, t.b, t.a]
                    },
                    toHex: function() {
                        var arr = ArrayUtil.map(["r", "g", "b"], function(x) {
                            var s = this[x].toString(16);
                            return s.length < 2 ? "0" + s : s
                        }, this);
                        return "#" + arr.join("")
                    },
                    toCss: function(includeAlpha) {
                        var t = this,
                            rgb = t.r + ", " + t.g + ", " + t.b;
                        return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")"
                    },
                    toString: function() {
                        return this.toCss(true)
                    }
                });
                Color.blendColors = dojo.blendColors = function(start, end, weight, obj) {
                    var t = obj || new Color;
                    ArrayUtil.forEach(["r", "g", "b", "a"], function(x) {
                        t[x] = start[x] + (end[x] - start[x]) * weight;
                        if (x != "a") {
                            t[x] = Math.round(t[x])
                        }
                    });
                    return t.sanitize()
                };
                Color.fromRgb = dojo.colorFromRgb = function(color, obj) {
                    var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
                    return m && Color.fromArray(m[1].split(/\s*,\s*/), obj)
                };
                Color.fromHex = dojo.colorFromHex = function(color, obj) {
                    var t = obj || new Color,
                        bits = color.length == 4 ? 4 : 8,
                        mask = (1 << bits) - 1;
                    color = Number("0x" + color.substr(1));
                    if (isNaN(color)) {
                        return null
                    }
                    ArrayUtil.forEach(["b", "g", "r"], function(x) {
                        var c = color & mask;
                        color >>= bits;
                        t[x] = bits == 4 ? 17 * c : c
                    });
                    t.a = 1;
                    return t
                };
                Color.fromArray = dojo.colorFromArray = function(a, obj) {
                    var t = obj || new Color;
                    t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
                    if (isNaN(t.a)) {
                        t.a = 1
                    }
                    return t.sanitize()
                };
                Color.fromString = dojo.colorFromString = function(str, obj) {
                    var a = Color.named[str];
                    return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj)
                };
                return Color
            })
        },
        "dojo/_base/browser": function() {
            if (require.has) {
                require.has.add("config-selectorEngine", "acme")
            }
            define(["../ready", "./kernel", "./connect", "./unload", "./window", "./event", "./html", "./NodeList", "../query", "./xhr", "./fx"], function(dojo) {
                return dojo
            })
        },
        "dojo/_base/unload": function() {
            define(["./kernel", "./lang", "../on"], function(dojo, lang, on) {
                var win = window;
                var unload = {
                    addOnWindowUnload: function(obj, functionName) {
                        if (!dojo.windowUnloaded) {
                            on(win, "unload", dojo.windowUnloaded = function() {})
                        }
                        on(win, "unload", lang.hitch(obj, functionName))
                    },
                    addOnUnload: function(obj, functionName) {
                        on(win, "beforeunload", lang.hitch(obj, functionName))
                    }
                };
                dojo.addOnWindowUnload = unload.addOnWindowUnload;
                dojo.addOnUnload = unload.addOnUnload;
                return unload
            })
        },
        "dojo/_base/html": function() {
            define(["./kernel", "../dom", "../dom-style", "../dom-attr", "../dom-prop", "../dom-class", "../dom-construct", "../dom-geometry"], function(dojo, dom, style, attr, prop, cls, ctr, geom) {
                dojo.byId = dom.byId;
                dojo.isDescendant = dom.isDescendant;
                dojo.setSelectable = dom.setSelectable;
                dojo.getAttr = attr.get;
                dojo.setAttr = attr.set;
                dojo.hasAttr = attr.has;
                dojo.removeAttr = attr.remove;
                dojo.getNodeProp = attr.getNodeProp;
                dojo.attr = function(node, name, value) {
                    if (arguments.length == 2) {
                        return attr[typeof name == "string" ? "get" : "set"](node, name)
                    }
                    return attr.set(node, name, value)
                };
                dojo.hasClass = cls.contains;
                dojo.addClass = cls.add;
                dojo.removeClass = cls.remove;
                dojo.toggleClass = cls.toggle;
                dojo.replaceClass = cls.replace;
                dojo._toDom = dojo.toDom = ctr.toDom;
                dojo.place = ctr.place;
                dojo.create = ctr.create;
                dojo.empty = function(node) {
                    ctr.empty(node)
                };
                dojo._destroyElement = dojo.destroy = function(node) {
                    ctr.destroy(node)
                };
                dojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;
                dojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;
                dojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;
                dojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;
                dojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;
                dojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;
                dojo.setMarginBox = geom.setMarginBox;
                dojo._getContentBox = dojo.getContentBox = geom.getContentBox;
                dojo.setContentSize = geom.setContentSize;
                dojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;
                dojo._docScroll = dojo.docScroll = geom.docScroll;
                dojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;
                dojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;
                dojo.position = geom.position;
                dojo.marginBox = function marginBox(node, box) {
                    return box ? geom.setMarginBox(node, box) : geom.getMarginBox(node)
                };
                dojo.contentBox = function contentBox(node, box) {
                    return box ? geom.setContentSize(node, box) : geom.getContentBox(node)
                };
                dojo.coords = function(node, includeScroll) {
                    dojo.deprecated("dojo.coords()", "Use dojo.position() or dojo.marginBox().");
                    node = dom.byId(node);
                    var s = style.getComputedStyle(node),
                        mb = geom.getMarginBox(node, s);
                    var abs = geom.position(node, includeScroll);
                    mb.x = abs.x;
                    mb.y = abs.y;
                    return mb
                };
                dojo.getProp = prop.get;
                dojo.setProp = prop.set;
                dojo.prop = function(node, name, value) {
                    if (arguments.length == 2) {
                        return prop[typeof name == "string" ? "get" : "set"](node, name)
                    }
                    return prop.set(node, name, value)
                };
                dojo.getStyle = style.get;
                dojo.setStyle = style.set;
                dojo.getComputedStyle = style.getComputedStyle;
                dojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;
                dojo.style = function(node, name, value) {
                    switch (arguments.length) {
                        case 1:
                            return style.get(node);
                        case 2:
                            return style[typeof name == "string" ? "get" : "set"](node, name)
                    }
                    return style.set(node, name, value)
                };
                return dojo
            })
        },
        "dojo/dom-attr": function() {
            define(["exports", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-prop"], function(exports, has, lang, dom, style, prop) {
                var forcePropNames = {
                        innerHTML: 1,
                        textContent: 1,
                        className: 1,
                        htmlFor: has("ie"),
                        value: 1
                    },
                    attrNames = {
                        classname: "class",
                        htmlfor: "for",
                        tabindex: "tabIndex",
                        readonly: "readOnly"
                    };

                function _hasAttr(node, name) {
                    var attr = node.getAttributeNode && node.getAttributeNode(name);
                    return !!attr && attr.specified
                }
                exports.has = function hasAttr(node, name) {
                    var lc = name.toLowerCase();
                    return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name)
                };
                exports.get = function getAttr(node, name) {
                    node = dom.byId(node);
                    var lc = name.toLowerCase(),
                        propName = prop.names[lc] || name,
                        forceProp = forcePropNames[propName],
                        value = node[propName];
                    if (forceProp && typeof value != "undefined") {
                        return value
                    }
                    if (propName == "textContent") {
                        return prop.get(node, propName)
                    }
                    if (propName != "href" && (typeof value == "boolean" || lang.isFunction(value))) {
                        return value
                    }
                    var attrName = attrNames[lc] || name;
                    return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null
                };
                exports.set = function setAttr(node, name, value) {
                    node = dom.byId(node);
                    if (arguments.length == 2) {
                        for (var x in name) {
                            exports.set(node, x, name[x])
                        }
                        return node
                    }
                    var lc = name.toLowerCase(),
                        propName = prop.names[lc] || name,
                        forceProp = forcePropNames[propName];
                    if (propName == "style" && typeof value != "string") {
                        style.set(node, value);
                        return node
                    }
                    if (forceProp || typeof value == "boolean" || lang.isFunction(value)) {
                        return prop.set(node, name, value)
                    }
                    node.setAttribute(attrNames[lc] || name, value);
                    return node
                };
                exports.remove = function removeAttr(node, name) {
                    dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name)
                };
                exports.getNodeProp = function getNodeProp(node, name) {
                    node = dom.byId(node);
                    var lc = name.toLowerCase(),
                        propName = prop.names[lc] || name;
                    if (propName in node && propName != "href") {
                        return node[propName]
                    }
                    var attrName = attrNames[lc] || name;
                    return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null
                }
            })
        },
        "dojo/dom-prop": function() {
            define(["exports", "./_base/kernel", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-construct", "./_base/connect"], function(exports, dojo, has, lang, dom, style, ctr, conn) {
                var _evtHdlrMap = {},
                    _ctr = 0,
                    _attrId = dojo._scopeName + "attrid";
                has.add("dom-textContent", function(global, doc, element) {
                    return "textContent" in element
                });
                exports.names = {
                    "class": "className",
                    "for": "htmlFor",
                    tabindex: "tabIndex",
                    readonly: "readOnly",
                    colspan: "colSpan",
                    frameborder: "frameBorder",
                    rowspan: "rowSpan",
                    textcontent: "textContent",
                    valuetype: "valueType"
                };

                function getText(node) {
                    var text = "",
                        ch = node.childNodes;
                    for (var i = 0, n; n = ch[i]; i++) {
                        if (n.nodeType != 8) {
                            if (n.nodeType == 1) {
                                text += getText(n)
                            } else {
                                text += n.nodeValue
                            }
                        }
                    }
                    return text
                }
                exports.get = function getProp(node, name) {
                    node = dom.byId(node);
                    var lc = name.toLowerCase(),
                        propName = exports.names[lc] || name;
                    if (propName == "textContent" && !has("dom-textContent")) {
                        return getText(node)
                    }
                    return node[propName]
                };
                exports.set = function setProp(node, name, value) {
                    node = dom.byId(node);
                    var l = arguments.length;
                    if (l == 2 && typeof name != "string") {
                        for (var x in name) {
                            exports.set(node, x, name[x])
                        }
                        return node
                    }
                    var lc = name.toLowerCase(),
                        propName = exports.names[lc] || name;
                    if (propName == "style" && typeof value != "string") {
                        style.set(node, value);
                        return node
                    }
                    if (propName == "innerHTML") {
                        if (has("ie") && node.tagName.toLowerCase() in {
                                col: 1,
                                colgroup: 1,
                                table: 1,
                                tbody: 1,
                                tfoot: 1,
                                thead: 1,
                                tr: 1,
                                title: 1
                            }) {
                            ctr.empty(node);
                            node.appendChild(ctr.toDom(value, node.ownerDocument))
                        } else {
                            node[propName] = value
                        }
                        return node
                    }
                    if (propName == "textContent" && !has("dom-textContent")) {
                        ctr.empty(node);
                        node.appendChild(node.ownerDocument.createTextNode(value));
                        return node
                    }
                    if (lang.isFunction(value)) {
                        var attrId = node[_attrId];
                        if (!attrId) {
                            attrId = _ctr++;
                            node[_attrId] = attrId
                        }
                        if (!_evtHdlrMap[attrId]) {
                            _evtHdlrMap[attrId] = {}
                        }
                        var h = _evtHdlrMap[attrId][propName];
                        if (h) {
                            conn.disconnect(h)
                        } else {
                            try {
                                delete node[propName]
                            } catch (e) {}
                        }
                        if (value) {
                            _evtHdlrMap[attrId][propName] = conn.connect(node, propName, value)
                        } else {
                            node[propName] = null
                        }
                        return node
                    }
                    node[propName] = value;
                    return node
                }
            })
        },
        "dojo/dom-construct": function() {
            define(["exports", "./_base/kernel", "./sniff", "./_base/window", "./dom", "./dom-attr"], function(exports, dojo, has, win, dom, attr) {
                var tagWrap = {
                        option: ["select"],
                        tbody: ["table"],
                        thead: ["table"],
                        tfoot: ["table"],
                        tr: ["table", "tbody"],
                        td: ["table", "tbody", "tr"],
                        th: ["table", "thead", "tr"],
                        legend: ["fieldset"],
                        caption: ["table"],
                        colgroup: ["table"],
                        col: ["table", "colgroup"],
                        li: ["ul"]
                    },
                    reTag = /<\s*([\w\:]+)/,
                    masterNode = {},
                    masterNum = 0,
                    masterName = "__" + dojo._scopeName + "ToDomId";
                for (var param in tagWrap) {
                    if (tagWrap.hasOwnProperty(param)) {
                        var tw = tagWrap[param];
                        tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
                        tw.post = "</" + tw.reverse().join("></") + ">"
                    }
                }
                var html5domfix;
                if (has("ie") <= 8) {
                    html5domfix = function(doc) {
                        doc.__dojo_html5_tested = "yes";
                        var div = create("div", {
                            innerHTML: "<nav>a</nav>",
                            style: {
                                visibility: "hidden"
                            }
                        }, doc.body);
                        if (div.childNodes.length !== 1) {
                            ("abbr article aside audio canvas details figcaption figure footer header " + "hgroup mark meter nav output progress section summary time video").replace(/\b\w+\b/g, function(n) {
                                doc.createElement(n)
                            })
                        }
                        destroy(div)
                    }
                }

                function _insertBefore(node, ref) {
                    var parent = ref.parentNode;
                    if (parent) {
                        parent.insertBefore(node, ref)
                    }
                }

                function _insertAfter(node, ref) {
                    var parent = ref.parentNode;
                    if (parent) {
                        if (parent.lastChild == ref) {
                            parent.appendChild(node)
                        } else {
                            parent.insertBefore(node, ref.nextSibling)
                        }
                    }
                }
                exports.toDom = function toDom(frag, doc) {
                    doc = doc || win.doc;
                    var masterId = doc[masterName];
                    if (!masterId) {
                        doc[masterName] = masterId = ++masterNum + "";
                        masterNode[masterId] = doc.createElement("div")
                    }
                    if (has("ie") <= 8) {
                        if (!doc.__dojo_html5_tested && doc.body) {
                            html5domfix(doc)
                        }
                    }
                    frag += "";
                    var match = frag.match(reTag),
                        tag = match ? match[1].toLowerCase() : "",
                        master = masterNode[masterId],
                        wrap, i, fc, df;
                    if (match && tagWrap[tag]) {
                        wrap = tagWrap[tag];
                        master.innerHTML = wrap.pre + frag + wrap.post;
                        for (i = wrap.length; i; --i) {
                            master = master.firstChild
                        }
                    } else {
                        master.innerHTML = frag
                    }
                    if (master.childNodes.length == 1) {
                        return master.removeChild(master.firstChild)
                    }
                    df = doc.createDocumentFragment();
                    while (fc = master.firstChild) {
                        df.appendChild(fc)
                    }
                    return df
                };
                exports.place = function place(node, refNode, position) {
                    refNode = dom.byId(refNode);
                    if (typeof node == "string") {
                        node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node)
                    }
                    if (typeof position == "number") {
                        var cn = refNode.childNodes;
                        if (!cn.length || cn.length <= position) {
                            refNode.appendChild(node)
                        } else {
                            _insertBefore(node, cn[position < 0 ? 0 : position])
                        }
                    } else {
                        switch (position) {
                            case "before":
                                _insertBefore(node, refNode);
                                break;
                            case "after":
                                _insertAfter(node, refNode);
                                break;
                            case "replace":
                                refNode.parentNode.replaceChild(node, refNode);
                                break;
                            case "only":
                                exports.empty(refNode);
                                refNode.appendChild(node);
                                break;
                            case "first":
                                if (refNode.firstChild) {
                                    _insertBefore(node, refNode.firstChild);
                                    break
                                }
                            default:
                                refNode.appendChild(node)
                        }
                    }
                    return node
                };
                var create = exports.create = function create(tag, attrs, refNode, pos) {
                    var doc = win.doc;
                    if (refNode) {
                        refNode = dom.byId(refNode);
                        doc = refNode.ownerDocument
                    }
                    if (typeof tag == "string") {
                        tag = doc.createElement(tag)
                    }
                    if (attrs) {
                        attr.set(tag, attrs)
                    }
                    if (refNode) {
                        exports.place(tag, refNode, pos)
                    }
                    return tag
                };

                function _empty(node) {
                    if ("innerHTML" in node) {
                        try {
                            node.innerHTML = "";
                            return
                        } catch (e) {}
                    }
                    for (var c; c = node.lastChild;) {
                        node.removeChild(c)
                    }
                }
                exports.empty = function empty(node) {
                    _empty(dom.byId(node))
                };

                function _destroy(node, parent) {
                    if (node.firstChild) {
                        _empty(node)
                    }
                    if (parent) {
                        has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node)
                    }
                }
                var destroy = exports.destroy = function destroy(node) {
                    node = dom.byId(node);
                    if (!node) {
                        return
                    }
                    _destroy(node, node.parentNode)
                }
            })
        },
        "dojo/dom-class": function() {
            define(["./_base/lang", "./_base/array", "./dom"], function(lang, array, dom) {
                var className = "className";
                var cls, spaces = /\s+/,
                    a1 = [""];

                function str2array(s) {
                    if (typeof s == "string" || s instanceof String) {
                        if (s && !spaces.test(s)) {
                            a1[0] = s;
                            return a1
                        }
                        var a = s.split(spaces);
                        if (a.length && !a[0]) {
                            a.shift()
                        }
                        if (a.length && !a[a.length - 1]) {
                            a.pop()
                        }
                        return a
                    }
                    if (!s) {
                        return []
                    }
                    return array.filter(s, function(x) {
                        return x
                    })
                }
                var fakeNode = {};
                cls = {
                    contains: function containsClass(node, classStr) {
                        return (" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0
                    },
                    add: function addClass(node, classStr) {
                        node = dom.byId(node);
                        classStr = str2array(classStr);
                        var cls = node[className],
                            oldLen;
                        cls = cls ? " " + cls + " " : " ";
                        oldLen = cls.length;
                        for (var i = 0, len = classStr.length, c; i < len; ++i) {
                            c = classStr[i];
                            if (c && cls.indexOf(" " + c + " ") < 0) {
                                cls += c + " "
                            }
                        }
                        if (oldLen < cls.length) {
                            node[className] = cls.substr(1, cls.length - 2)
                        }
                    },
                    remove: function removeClass(node, classStr) {
                        node = dom.byId(node);
                        var cls;
                        if (classStr !== undefined) {
                            classStr = str2array(classStr);
                            cls = " " + node[className] + " ";
                            for (var i = 0, len = classStr.length; i < len; ++i) {
                                cls = cls.replace(" " + classStr[i] + " ", " ")
                            }
                            cls = lang.trim(cls)
                        } else {
                            cls = ""
                        }
                        if (node[className] != cls) {
                            node[className] = cls
                        }
                    },
                    replace: function replaceClass(node, addClassStr, removeClassStr) {
                        node = dom.byId(node);
                        fakeNode[className] = node[className];
                        cls.remove(fakeNode, removeClassStr);
                        cls.add(fakeNode, addClassStr);
                        if (node[className] !== fakeNode[className]) {
                            node[className] = fakeNode[className]
                        }
                    },
                    toggle: function toggleClass(node, classStr, condition) {
                        node = dom.byId(node);
                        if (condition === undefined) {
                            classStr = str2array(classStr);
                            for (var i = 0, len = classStr.length, c; i < len; ++i) {
                                c = classStr[i];
                                cls[cls.contains(node, c) ? "remove" : "add"](node, c)
                            }
                        } else {
                            cls[condition ? "add" : "remove"](node, classStr)
                        }
                        return condition
                    }
                };
                return cls
            })
        },
        "dojo/_base/NodeList": function() {
            define(["./kernel", "../query", "./array", "./html", "../NodeList-dom"], function(dojo, query, array) {
                var NodeList = query.NodeList,
                    nlp = NodeList.prototype;
                nlp.connect = NodeList._adaptAsForEach(function() {
                    return dojo.connect.apply(this, arguments)
                });
                nlp.coords = NodeList._adaptAsMap(dojo.coords);
                NodeList.events = ["blur", "focus", "change", "click", "error", "keydown", "keypress", "keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover", "mouseup", "submit"];
                array.forEach(NodeList.events, function(evt) {
                    var _oe = "on" + evt;
                    nlp[_oe] = function(a, b) {
                        return this.connect(_oe, a, b)
                    }
                });
                dojo.NodeList = NodeList;
                return NodeList
            })
        },
        "dojo/query": function() {
            define(["./_base/kernel", "./has", "./dom", "./on", "./_base/array", "./_base/lang", "./selector/_loader", "./selector/_loader!default"], function(dojo, has, dom, on, array, lang, loader, defaultEngine) {
                "use strict";
                has.add("array-extensible", function() {
                    return lang.delegate([], {
                        length: 1
                    }).length == 1 && !has("bug-for-in-skips-shadowed")
                });
                var ap = Array.prototype,
                    aps = ap.slice,
                    apc = ap.concat,
                    forEach = array.forEach;
                var tnl = function(a, parent, NodeListCtor) {
                    var nodeList = new(NodeListCtor || this._NodeListCtor || nl)(a);
                    return parent ? nodeList._stash(parent) : nodeList
                };
                var loopBody = function(f, a, o) {
                    a = [0].concat(aps.call(a, 0));
                    o = o || dojo.global;
                    return function(node) {
                        a[0] = node;
                        return f.apply(o, a)
                    }
                };
                var adaptAsForEach = function(f, o) {
                    return function() {
                        this.forEach(loopBody(f, arguments, o));
                        return this
                    }
                };
                var adaptAsMap = function(f, o) {
                    return function() {
                        return this.map(loopBody(f, arguments, o))
                    }
                };
                var adaptAsFilter = function(f, o) {
                    return function() {
                        return this.filter(loopBody(f, arguments, o))
                    }
                };
                var adaptWithCondition = function(f, g, o) {
                    return function() {
                        var a = arguments,
                            body = loopBody(f, a, o);
                        if (g.call(o || dojo.global, a)) {
                            return this.map(body)
                        }
                        this.forEach(body);
                        return this
                    }
                };
                var NodeList = function(array) {
                    var isNew = this instanceof nl && has("array-extensible");
                    if (typeof array == "number") {
                        array = Array(array)
                    }
                    var nodeArray = array && "length" in array ? array : arguments;
                    if (isNew || !nodeArray.sort) {
                        var target = isNew ? this : [],
                            l = target.length = nodeArray.length;
                        for (var i = 0; i < l; i++) {
                            target[i] = nodeArray[i]
                        }
                        if (isNew) {
                            return target
                        }
                        nodeArray = target
                    }
                    lang._mixin(nodeArray, nlp);
                    nodeArray._NodeListCtor = function(array) {
                        return nl(array)
                    };
                    return nodeArray
                };
                var nl = NodeList,
                    nlp = nl.prototype = has("array-extensible") ? [] : {};
                nl._wrap = nlp._wrap = tnl;
                nl._adaptAsMap = adaptAsMap;
                nl._adaptAsForEach = adaptAsForEach;
                nl._adaptAsFilter = adaptAsFilter;
                nl._adaptWithCondition = adaptWithCondition;
                forEach(["slice", "splice"], function(name) {
                    var f = ap[name];
                    nlp[name] = function() {
                        return this._wrap(f.apply(this, arguments), name == "slice" ? this : null)
                    }
                });
                forEach(["indexOf", "lastIndexOf", "every", "some"], function(name) {
                    var f = array[name];
                    nlp[name] = function() {
                        return f.apply(dojo, [this].concat(aps.call(arguments, 0)))
                    }
                });
                lang.extend(NodeList, {
                    constructor: nl,
                    _NodeListCtor: nl,
                    toString: function() {
                        return this.join(",")
                    },
                    _stash: function(parent) {
                        this._parent = parent;
                        return this
                    },
                    on: function(eventName, listener) {
                        var handles = this.map(function(node) {
                            return on(node, eventName, listener)
                        });
                        handles.remove = function() {
                            for (var i = 0; i < handles.length; i++) {
                                handles[i].remove()
                            }
                        };
                        return handles
                    },
                    end: function() {
                        if (this._parent) {
                            return this._parent
                        } else {
                            return new this._NodeListCtor(0)
                        }
                    },
                    concat: function(item) {
                        var t = aps.call(this, 0),
                            m = array.map(arguments, function(a) {
                                return aps.call(a, 0)
                            });
                        return this._wrap(apc.apply(t, m), this)
                    },
                    map: function(func, obj) {
                        return this._wrap(array.map(this, func, obj), this)
                    },
                    forEach: function(callback, thisObj) {
                        forEach(this, callback, thisObj);
                        return this
                    },
                    filter: function(filter) {
                        var a = arguments,
                            items = this,
                            start = 0;
                        if (typeof filter == "string") {
                            items = query._filterResult(this, a[0]);
                            if (a.length == 1) {
                                return items._stash(this)
                            }
                            start = 1
                        }
                        return this._wrap(array.filter(items, a[start], a[start + 1]), this)
                    },
                    instantiate: function(declaredClass, properties) {
                        var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
                        properties = properties || {};
                        return this.forEach(function(node) {
                            new c(properties, node)
                        })
                    },
                    at: function() {
                        var t = new this._NodeListCtor(0);
                        forEach(arguments, function(i) {
                            if (i < 0) {
                                i = this.length + i
                            }
                            if (this[i]) {
                                t.push(this[i])
                            }
                        }, this);
                        return t._stash(this)
                    }
                });

                function queryForEngine(engine, NodeList) {
                    var query = function(query, root) {
                        if (typeof root == "string") {
                            root = dom.byId(root);
                            if (!root) {
                                return new NodeList([])
                            }
                        }
                        var results = typeof query == "string" ? engine(query, root) : query ? query.end && query.on ? query : [query] : [];
                        if (results.end && results.on) {
                            return results
                        }
                        return new NodeList(results)
                    };
                    query.matches = engine.match || function(node, selector, root) {
                        return query.filter([node], selector, root).length > 0
                    };
                    query.filter = engine.filter || function(nodes, selector, root) {
                        return query(selector, root).filter(function(node) {
                            return array.indexOf(nodes, node) > -1
                        })
                    };
                    if (typeof engine != "function") {
                        var search = engine.search;
                        engine = function(selector, root) {
                            return search(root || document, selector)
                        }
                    }
                    return query
                }
                var query = queryForEngine(defaultEngine, NodeList);
                dojo.query = queryForEngine(defaultEngine, function(array) {
                    return NodeList(array)
                });
                query.load = function(id, parentRequire, loaded) {
                    loader.load(id, parentRequire, function(engine) {
                        loaded(queryForEngine(engine, NodeList))
                    })
                };
                dojo._filterQueryResult = query._filterResult = function(nodes, selector, root) {
                    return new NodeList(query.filter(nodes, selector, root))
                };
                dojo.NodeList = query.NodeList = NodeList;
                return query
            })
        },
        "dojo/selector/_loader": function() {
            define(["../has", "require"], function(has, require) {
                "use strict";
                var testDiv = document.createElement("div");
                has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
                has.add("dom-qsa3", function() {
                    try {
                        testDiv.innerHTML = "<p class='TEST'></p>";
                        return testDiv.querySelectorAll(".TEST:empty").length == 1
                    } catch (e) {}
                });
                var fullEngine;
                var acme = "./acme",
                    lite = "./lite";
                return {
                    load: function(id, parentRequire, loaded, config) {
                        var req = require;
                        id = id == "default" ? has("config-selectorEngine") || "css3" : id;
                        id = id == "css2" || id == "lite" ? lite : id == "css2.1" ? has("dom-qsa2.1") ? lite : acme : id == "css3" ? has("dom-qsa3") ? lite : acme : id == "acme" ? acme : (req = parentRequire) && id;
                        if (id.charAt(id.length - 1) == "?") {
                            id = id.substring(0, id.length - 1);
                            var optionalLoad = true
                        }
                        if (optionalLoad && (has("dom-compliant-qsa") || fullEngine)) {
                            return loaded(fullEngine)
                        }
                        req([id], function(engine) {
                            if (id != "./lite") {
                                fullEngine = engine
                            }
                            loaded(engine)
                        })
                    }
                }
            })
        },
        "dojo/selector/lite": function() {
            define(["../has", "../_base/kernel"], function(has, dojo) {
                "use strict";
                var testDiv = document.createElement("div");
                var matchesSelector = testDiv.matches || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;
                var querySelectorAll = testDiv.querySelectorAll;
                var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
                has.add("dom-matches-selector", !!matchesSelector);
                has.add("dom-qsa", !!querySelectorAll);
                var liteEngine = function(selector, root) {
                    if (combine && selector.indexOf(",") > -1) {
                        return combine(selector, root)
                    }
                    var doc = root ? root.ownerDocument || root : dojo.doc || document,
                        match = (querySelectorAll ? /^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : /^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/).exec(selector);
                    root = root || doc;
                    if (match) {
                        if (match[2]) {
                            var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
                            if (!found || match[1] && match[1] != found.tagName.toLowerCase()) {
                                return []
                            }
                            if (root != doc) {
                                var parent = found;
                                while (parent != root) {
                                    parent = parent.parentNode;
                                    if (!parent) {
                                        return []
                                    }
                                }
                            }
                            return match[3] ? liteEngine(match[3], found) : [found]
                        }
                        if (match[3] && root.getElementsByClassName) {
                            return root.getElementsByClassName(match[4])
                        }
                        var found;
                        if (match[5]) {
                            found = root.getElementsByTagName(match[5]);
                            if (match[4] || match[6]) {
                                selector = (match[4] || "") + match[6]
                            } else {
                                return found
                            }
                        }
                    }
                    if (querySelectorAll) {
                        if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object") {
                            return useRoot(root, selector, root.querySelectorAll)
                        } else {
                            return root.querySelectorAll(selector)
                        }
                    } else if (!found) {
                        found = root.getElementsByTagName("*")
                    }
                    var results = [];
                    for (var i = 0, l = found.length; i < l; i++) {
                        var node = found[i];
                        if (node.nodeType == 1 && jsMatchesSelector(node, selector, root)) {
                            results.push(node)
                        }
                    }
                    return results
                };
                var useRoot = function(context, query, method) {
                    var oldContext = context,
                        old = context.getAttribute("id"),
                        nid = old || "__dojo__",
                        hasParent = context.parentNode,
                        relativeHierarchySelector = /^\s*[+~]/.test(query);
                    if (relativeHierarchySelector && !hasParent) {
                        return []
                    }
                    if (!old) {
                        context.setAttribute("id", nid)
                    } else {
                        nid = nid.replace(/'/g, "\\$&")
                    }
                    if (relativeHierarchySelector && hasParent) {
                        context = context.parentNode
                    }
                    var selectors = query.match(unionSplit);
                    for (var i = 0; i < selectors.length; i++) {
                        selectors[i] = "[id='" + nid + "'] " + selectors[i]
                    }
                    query = selectors.join(",");
                    try {
                        return method.call(context, query)
                    } finally {
                        if (!old) {
                            oldContext.removeAttribute("id")
                        }
                    }
                };
                if (!has("dom-matches-selector")) {
                    var jsMatchesSelector = function() {
                        var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
                        var selectorTypes = {
                            "": function(tagName) {
                                tagName = tagName[caseFix]();
                                return function(node) {
                                    return node.tagName == tagName
                                }
                            },
                            ".": function(className) {
                                var classNameSpaced = " " + className + " ";
                                return function(node) {
                                    return node.className.indexOf(className) > -1 && (" " + node.className + " ").indexOf(classNameSpaced) > -1
                                }
                            },
                            "#": function(id) {
                                return function(node) {
                                    return node.id == id
                                }
                            }
                        };
                        var attrComparators = {
                            "^=": function(attrValue, value) {
                                return attrValue.indexOf(value) == 0
                            },
                            "*=": function(attrValue, value) {
                                return attrValue.indexOf(value) > -1
                            },
                            "$=": function(attrValue, value) {
                                return attrValue.substring(attrValue.length - value.length, attrValue.length) == value
                            },
                            "~=": function(attrValue, value) {
                                return (" " + attrValue + " ").indexOf(" " + value + " ") > -1
                            },
                            "|=": function(attrValue, value) {
                                return (attrValue + "-").indexOf(value + "-") == 0
                            },
                            "=": function(attrValue, value) {
                                return attrValue == value
                            },
                            "": function(attrValue, value) {
                                return true
                            }
                        };

                        function attr(name, value, type) {
                            var firstChar = value.charAt(0);
                            if (firstChar == '"' || firstChar == "'") {
                                value = value.slice(1, -1)
                            }
                            value = value.replace(/\\/g, "");
                            var comparator = attrComparators[type || ""];
                            return function(node) {
                                var attrValue = node.getAttribute(name);
                                return attrValue && comparator(attrValue, value)
                            }
                        }

                        function ancestor(matcher) {
                            return function(node, root) {
                                while ((node = node.parentNode) != root) {
                                    if (matcher(node, root)) {
                                        return true
                                    }
                                }
                            }
                        }

                        function parent(matcher) {
                            return function(node, root) {
                                node = node.parentNode;
                                return matcher ? node != root && matcher(node, root) : node == root
                            }
                        }
                        var cache = {};

                        function and(matcher, next) {
                            return matcher ? function(node, root) {
                                return next(node) && matcher(node, root)
                            } : next
                        }
                        return function(node, selector, root) {
                            var matcher = cache[selector];
                            if (!matcher) {
                                if (selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue) {
                                        if (value) {
                                            matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, "")))
                                        } else if (combinator) {
                                            matcher = (combinator == " " ? ancestor : parent)(matcher)
                                        } else if (attrName) {
                                            matcher = and(matcher, attr(attrName, attrValue, attrType))
                                        }
                                        return ""
                                    })) {
                                    throw new Error("Syntax error in query")
                                }
                                if (!matcher) {
                                    return true
                                }
                                cache[selector] = matcher
                            }
                            return matcher(node, root)
                        }
                    }()
                }
                if (!has("dom-qsa")) {
                    var combine = function(selector, root) {
                        var selectors = selector.match(unionSplit);
                        var indexed = [];
                        for (var i = 0; i < selectors.length; i++) {
                            selector = new String(selectors[i].replace(/\s*$/, ""));
                            selector.indexOf = escape;
                            var results = liteEngine(selector, root);
                            for (var j = 0, l = results.length; j < l; j++) {
                                var node = results[j];
                                indexed[node.sourceIndex] = node
                            }
                        }
                        var totalResults = [];
                        for (i in indexed) {
                            totalResults.push(indexed[i])
                        }
                        return totalResults
                    }
                }
                liteEngine.match = matchesSelector ? function(node, selector, root) {
                    if (root && root.nodeType != 9) {
                        return useRoot(root, selector, function(query) {
                            return matchesSelector.call(node, query)
                        })
                    }
                    return matchesSelector.call(node, selector)
                } : jsMatchesSelector;
                return liteEngine
            })
        },
        "dojo/NodeList-dom": function() {
            define(["./_base/kernel", "./query", "./_base/array", "./_base/lang", "./dom-class", "./dom-construct", "./dom-geometry", "./dom-attr", "./dom-style"], function(dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle) {
                var magicGuard = function(a) {
                    return a.length == 1 && typeof a[0] == "string"
                };
                var orphan = function(node) {
                    var p = node.parentNode;
                    if (p) {
                        p.removeChild(node)
                    }
                };
                var NodeList = query.NodeList,
                    awc = NodeList._adaptWithCondition,
                    aafe = NodeList._adaptAsForEach,
                    aam = NodeList._adaptAsMap;

                function getSet(module) {
                    return function(node, name, value) {
                        if (arguments.length == 2) {
                            return module[typeof name == "string" ? "get" : "set"](node, name)
                        }
                        return module.set(node, name, value)
                    }
                }
                lang.extend(NodeList, {
                    _normalize: function(content, refNode) {
                        var parse = content.parse === true;
                        if (typeof content.template == "string") {
                            var templateFunc = content.templateFunc || dojo.string && dojo.string.substitute;
                            content = templateFunc ? templateFunc(content.template, content) : content
                        }
                        var type = typeof content;
                        if (type == "string" || type == "number") {
                            content = domCtr.toDom(content, refNode && refNode.ownerDocument);
                            if (content.nodeType == 11) {
                                content = lang._toArray(content.childNodes)
                            } else {
                                content = [content]
                            }
                        } else if (!lang.isArrayLike(content)) {
                            content = [content]
                        } else if (!lang.isArray(content)) {
                            content = lang._toArray(content)
                        }
                        if (parse) {
                            content._runParse = true
                        }
                        return content
                    },
                    _cloneNode: function(node) {
                        return node.cloneNode(true)
                    },
                    _place: function(ary, refNode, position, useClone) {
                        if (refNode.nodeType != 1 && position == "only") {
                            return
                        }
                        var rNode = refNode,
                            tempNode;
                        var length = ary.length;
                        for (var i = length - 1; i >= 0; i--) {
                            var node = useClone ? this._cloneNode(ary[i]) : ary[i];
                            if (ary._runParse && dojo.parser && dojo.parser.parse) {
                                if (!tempNode) {
                                    tempNode = rNode.ownerDocument.createElement("div")
                                }
                                tempNode.appendChild(node);
                                dojo.parser.parse(tempNode);
                                node = tempNode.firstChild;
                                while (tempNode.firstChild) {
                                    tempNode.removeChild(tempNode.firstChild)
                                }
                            }
                            if (i == length - 1) {
                                domCtr.place(node, rNode, position)
                            } else {
                                rNode.parentNode.insertBefore(node, rNode)
                            }
                            rNode = node
                        }
                    },
                    position: aam(domGeom.position),
                    attr: awc(getSet(domAttr), magicGuard),
                    style: awc(getSet(domStyle), magicGuard),
                    addClass: aafe(domCls.add),
                    removeClass: aafe(domCls.remove),
                    toggleClass: aafe(domCls.toggle),
                    replaceClass: aafe(domCls.replace),
                    empty: aafe(domCtr.empty),
                    removeAttr: aafe(domAttr.remove),
                    marginBox: aam(domGeom.getMarginBox),
                    place: function(queryOrNode, position) {
                        var item = query(queryOrNode)[0];
                        return this.forEach(function(node) {
                            domCtr.place(node, item, position)
                        })
                    },
                    orphan: function(filter) {
                        return (filter ? query._filterResult(this, filter) : this).forEach(orphan)
                    },
                    adopt: function(queryOrListOrNode, position) {
                        return query(queryOrListOrNode).place(this[0], position)._stash(this)
                    },
                    query: function(queryStr) {
                        if (!queryStr) {
                            return this
                        }
                        var ret = new NodeList;
                        this.map(function(node) {
                            query(queryStr, node).forEach(function(subNode) {
                                if (subNode !== undefined) {
                                    ret.push(subNode)
                                }
                            })
                        });
                        return ret._stash(this)
                    },
                    filter: function(filter) {
                        var a = arguments,
                            items = this,
                            start = 0;
                        if (typeof filter == "string") {
                            items = query._filterResult(this, a[0]);
                            if (a.length == 1) {
                                return items._stash(this)
                            }
                            start = 1
                        }
                        return this._wrap(array.filter(items, a[start], a[start + 1]), this)
                    },
                    addContent: function(content, position) {
                        content = this._normalize(content, this[0]);
                        for (var i = 0, node; node = this[i]; i++) {
                            if (content.length) {
                                this._place(content, node, position, i > 0)
                            } else {
                                domCtr.empty(node)
                            }
                        }
                        return this
                    }
                });
                return NodeList
            })
        },
        "dojo/_base/xhr": function() {
            define(["./kernel", "./sniff", "require", "../io-query", "../dom", "../dom-form", "./Deferred", "./config", "./json", "./lang", "./array", "../on", "../aspect", "../request/watch", "../request/xhr", "../request/util"], function(dojo, has, require, ioq, dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util) {
                dojo._xhrObj = _xhr._create;
                var cfg = dojo.config;
                dojo.objectToQuery = ioq.objectToQuery;
                dojo.queryToObject = ioq.queryToObject;
                dojo.fieldToObject = domForm.fieldToObject;
                dojo.formToObject = domForm.toObject;
                dojo.formToQuery = domForm.toQuery;
                dojo.formToJson = domForm.toJson;
                dojo._blockAsync = false;
                var handlers = dojo._contentHandlers = dojo.contentHandlers = {
                    text: function(xhr) {
                        return xhr.responseText
                    },
                    json: function(xhr) {
                        return json.fromJson(xhr.responseText || null)
                    },
                    "json-comment-filtered": function(xhr) {
                        if (!config.useCommentedJson) {
                            console.warn("Consider using the standard mimetype:application/json." + " json-commenting can introduce security issues. To" + " decrease the chances of hijacking, use the standard the 'json' handler and" + " prefix your json with: {}&&\n" + "Use djConfig.useCommentedJson=true to turn off this message.")
                        }
                        var value = xhr.responseText;
                        var cStartIdx = value.indexOf("/*");
                        var cEndIdx = value.lastIndexOf("*/");
                        if (cStartIdx == -1 || cEndIdx == -1) {
                            throw new Error("JSON was not comment filtered")
                        }
                        return json.fromJson(value.substring(cStartIdx + 2, cEndIdx))
                    },
                    javascript: function(xhr) {
                        return dojo.eval(xhr.responseText)
                    },
                    xml: function(xhr) {
                        var result = xhr.responseXML;
                        if (result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")) {
                            result = (new DOMParser).parseFromString(xhr.responseText, "application/xml")
                        }
                        if (has("ie")) {
                            if (!result || !result.documentElement) {
                                var ms = function(n) {
                                    return "MSXML" + n + ".DOMDocument"
                                };
                                var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
                                array.some(dp, function(p) {
                                    try {
                                        var dom = new ActiveXObject(p);
                                        dom.async = false;
                                        dom.loadXML(xhr.responseText);
                                        result = dom
                                    } catch (e) {
                                        return false
                                    }
                                    return true
                                })
                            }
                        }
                        return result
                    },
                    "json-comment-optional": function(xhr) {
                        if (xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)) {
                            return handlers["json-comment-filtered"](xhr)
                        } else {
                            return handlers["json"](xhr)
                        }
                    }
                };
                dojo._ioSetArgs = function(args, canceller, okHandler, errHandler) {
                    var ioArgs = {
                        args: args,
                        url: args.url
                    };
                    var formObject = null;
                    if (args.form) {
                        var form = dom.byId(args.form);
                        var actnNode = form.getAttributeNode("action");
                        ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
                        formObject = domForm.toObject(form)
                    }
                    var miArgs = [{}];
                    if (formObject) {
                        miArgs.push(formObject)
                    }
                    if (args.content) {
                        miArgs.push(args.content)
                    }
                    if (args.preventCache) {
                        miArgs.push({
                            "dojo.preventCache": (new Date).valueOf()
                        })
                    }
                    ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));
                    ioArgs.handleAs = args.handleAs || "text";
                    var d = new Deferred(function(dfd) {
                        dfd.canceled = true;
                        canceller && canceller(dfd);
                        var err = dfd.ioArgs.error;
                        if (!err) {
                            err = new Error("request cancelled");
                            err.dojoType = "cancel";
                            dfd.ioArgs.error = err
                        }
                        return err
                    });
                    d.addCallback(okHandler);
                    var ld = args.load;
                    if (ld && lang.isFunction(ld)) {
                        d.addCallback(function(value) {
                            return ld.call(args, value, ioArgs)
                        })
                    }
                    var err = args.error;
                    if (err && lang.isFunction(err)) {
                        d.addErrback(function(value) {
                            return err.call(args, value, ioArgs)
                        })
                    }
                    var handle = args.handle;
                    if (handle && lang.isFunction(handle)) {
                        d.addBoth(function(value) {
                            return handle.call(args, value, ioArgs)
                        })
                    }
                    d.addErrback(function(error) {
                        return errHandler(error, d)
                    });
                    if (cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false) {
                        d.addCallbacks(function(res) {
                            dojo.publish("/dojo/io/load", [d, res]);
                            return res
                        }, function(res) {
                            dojo.publish("/dojo/io/error", [d, res]);
                            return res
                        });
                        d.addBoth(function(res) {
                            dojo.publish("/dojo/io/done", [d, res]);
                            return res
                        })
                    }
                    d.ioArgs = ioArgs;
                    return d
                };
                var _deferredOk = function(dfd) {
                    var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
                    return ret === undefined ? null : ret
                };
                var _deferError = function(error, dfd) {
                    if (!dfd.ioArgs.args.failOk) {
                        console.error(error)
                    }
                    return error
                };
                var _checkPubCount = function(dfd) {
                    if (_pubCount <= 0) {
                        _pubCount = 0;
                        if (cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)) {
                            dojo.publish("/dojo/io/stop")
                        }
                    }
                };
                var _pubCount = 0;
                aspect.after(watch, "_onAction", function() {
                    _pubCount -= 1
                });
                aspect.after(watch, "_onInFlight", _checkPubCount);
                dojo._ioCancelAll = watch.cancelAll;
                dojo._ioNotifyStart = function(dfd) {
                    if (cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false) {
                        if (!_pubCount) {
                            dojo.publish("/dojo/io/start")
                        }
                        _pubCount += 1;
                        dojo.publish("/dojo/io/send", [dfd])
                    }
                };
                dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle) {
                    var args = dfd.ioArgs.options = dfd.ioArgs.args;
                    lang.mixin(dfd, {
                        response: dfd.ioArgs,
                        isValid: function(response) {
                            return validCheck(dfd)
                        },
                        isReady: function(response) {
                            return ioCheck(dfd)
                        },
                        handleResponse: function(response) {
                            return resHandle(dfd)
                        }
                    });
                    watch(dfd);
                    _checkPubCount(dfd)
                };
                var _defaultContentType = "application/x-www-form-urlencoded";
                dojo._ioAddQueryToUrl = function(ioArgs) {
                    if (ioArgs.query.length) {
                        ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
                        ioArgs.query = null
                    }
                };
                dojo.xhr = function(method, args, hasBody) {
                    var rDfd;
                    var dfd = dojo._ioSetArgs(args, function(dfd) {
                        rDfd && rDfd.cancel()
                    }, _deferredOk, _deferError);
                    var ioArgs = dfd.ioArgs;
                    if ("postData" in args) {
                        ioArgs.query = args.postData
                    } else if ("putData" in args) {
                        ioArgs.query = args.putData
                    } else if ("rawBody" in args) {
                        ioArgs.query = args.rawBody
                    } else if (arguments.length > 2 && !hasBody || "POST|PUT".indexOf(method.toUpperCase()) === -1) {
                        dojo._ioAddQueryToUrl(ioArgs)
                    }
                    var options = {
                        method: method,
                        handleAs: "text",
                        timeout: args.timeout,
                        withCredentials: args.withCredentials,
                        ioArgs: ioArgs
                    };
                    if (typeof args.headers !== "undefined") {
                        options.headers = args.headers
                    }
                    if (typeof args.contentType !== "undefined") {
                        if (!options.headers) {
                            options.headers = {}
                        }
                        options.headers["Content-Type"] = args.contentType
                    }
                    if (typeof ioArgs.query !== "undefined") {
                        options.data = ioArgs.query
                    }
                    if (typeof args.sync !== "undefined") {
                        options.sync = args.sync
                    }
                    dojo._ioNotifyStart(dfd);
                    try {
                        rDfd = _xhr(ioArgs.url, options, true)
                    } catch (e) {
                        dfd.cancel();
                        return dfd
                    }
                    dfd.ioArgs.xhr = rDfd.response.xhr;
                    rDfd.then(function() {
                        dfd.resolve(dfd)
                    }).otherwise(function(error) {
                        ioArgs.error = error;
                        if (error.response) {
                            error.status = error.response.status;
                            error.responseText = error.response.text;
                            error.xhr = error.response.xhr
                        }
                        dfd.reject(error)
                    });
                    return dfd
                };
                dojo.xhrGet = function(args) {
                    return dojo.xhr("GET", args)
                };
                dojo.rawXhrPost = dojo.xhrPost = function(args) {
                    return dojo.xhr("POST", args, true)
                };
                dojo.rawXhrPut = dojo.xhrPut = function(args) {
                    return dojo.xhr("PUT", args, true)
                };
                dojo.xhrDelete = function(args) {
                    return dojo.xhr("DELETE", args)
                };
                dojo._isDocumentOk = function(x) {
                    return util.checkStatus(x.status)
                };
                dojo._getText = function(url) {
                    var result;
                    dojo.xhrGet({
                        url: url,
                        sync: true,
                        load: function(text) {
                            result = text
                        }
                    });
                    return result
                };
                lang.mixin(dojo.xhr, {
                    _xhrObj: dojo._xhrObj,
                    fieldToObject: domForm.fieldToObject,
                    formToObject: domForm.toObject,
                    objectToQuery: ioq.objectToQuery,
                    formToQuery: domForm.toQuery,
                    formToJson: domForm.toJson,
                    queryToObject: ioq.queryToObject,
                    contentHandlers: handlers,
                    _ioSetArgs: dojo._ioSetArgs,
                    _ioCancelAll: dojo._ioCancelAll,
                    _ioNotifyStart: dojo._ioNotifyStart,
                    _ioWatch: dojo._ioWatch,
                    _ioAddQueryToUrl: dojo._ioAddQueryToUrl,
                    _isDocumentOk: dojo._isDocumentOk,
                    _getText: dojo._getText,
                    get: dojo.xhrGet,
                    post: dojo.xhrPost,
                    put: dojo.xhrPut,
                    del: dojo.xhrDelete
                });
                return dojo.xhr
            })
        },
        "dojo/io-query": function() {
            define(["./_base/lang"], function(lang) {
                var backstop = {};
                return {
                    objectToQuery: function objectToQuery(map) {
                        var enc = encodeURIComponent,
                            pairs = [];
                        for (var name in map) {
                            var value = map[name];
                            if (value != backstop[name]) {
                                var assign = enc(name) + "=";
                                if (lang.isArray(value)) {
                                    for (var i = 0, l = value.length; i < l; ++i) {
                                        pairs.push(assign + enc(value[i]))
                                    }
                                } else {
                                    pairs.push(assign + enc(value))
                                }
                            }
                        }
                        return pairs.join("&")
                    },
                    queryToObject: function queryToObject(str) {
                        var dec = decodeURIComponent,
                            qp = str.split("&"),
                            ret = {},
                            name, val;
                        for (var i = 0, l = qp.length, item; i < l; ++i) {
                            item = qp[i];
                            if (item.length) {
                                var s = item.indexOf("=");
                                if (s < 0) {
                                    name = dec(item);
                                    val = ""
                                } else {
                                    name = dec(item.slice(0, s));
                                    val = dec(item.slice(s + 1))
                                }
                                if (typeof ret[name] == "string") {
                                    ret[name] = [ret[name]]
                                }
                                if (lang.isArray(ret[name])) {
                                    ret[name].push(val)
                                } else {
                                    ret[name] = val
                                }
                            }
                        }
                        return ret
                    }
                }
            })
        },
        "dojo/dom-form": function() {
            define(["./_base/lang", "./dom", "./io-query", "./json"], function(lang, dom, ioq, json) {
                function setValue(obj, name, value) {
                    if (value === null) {
                        return
                    }
                    var val = obj[name];
                    if (typeof val == "string") {
                        obj[name] = [val, value]
                    } else if (lang.isArray(val)) {
                        val.push(value)
                    } else {
                        obj[name] = value
                    }
                }
                var exclude = "file|submit|image|reset|button";
                var form = {
                    fieldToObject: function fieldToObject(inputNode) {
                        var ret = null;
                        inputNode = dom.byId(inputNode);
                        if (inputNode) {
                            var _in = inputNode.name,
                                type = (inputNode.type || "").toLowerCase();
                            if (_in && type && !inputNode.disabled) {
                                if (type == "radio" || type == "checkbox") {
                                    if (inputNode.checked) {
                                        ret = inputNode.value
                                    }
                                } else if (inputNode.multiple) {
                                    ret = [];
                                    var nodes = [inputNode.firstChild];
                                    while (nodes.length) {
                                        for (var node = nodes.pop(); node; node = node.nextSibling) {
                                            if (node.nodeType == 1 && node.tagName.toLowerCase() == "option") {
                                                if (node.selected) {
                                                    ret.push(node.value)
                                                }
                                            } else {
                                                if (node.nextSibling) {
                                                    nodes.push(node.nextSibling)
                                                }
                                                if (node.firstChild) {
                                                    nodes.push(node.firstChild)
                                                }
                                                break
                                            }
                                        }
                                    }
                                } else {
                                    ret = inputNode.value
                                }
                            }
                        }
                        return ret
                    },
                    toObject: function formToObject(formNode) {
                        var ret = {},
                            elems = dom.byId(formNode).elements;
                        for (var i = 0, l = elems.length; i < l; ++i) {
                            var item = elems[i],
                                _in = item.name,
                                type = (item.type || "").toLowerCase();
                            if (_in && type && exclude.indexOf(type) < 0 && !item.disabled) {
                                setValue(ret, _in, form.fieldToObject(item));
                                if (type == "image") {
                                    ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0
                                }
                            }
                        }
                        return ret
                    },
                    toQuery: function formToQuery(formNode) {
                        return ioq.objectToQuery(form.toObject(formNode))
                    },
                    toJson: function formToJson(formNode, prettyPrint) {
                        return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0)
                    }
                };
                return form
            })
        },
        "dojo/request/watch": function() {
            define(["./util", "../errors/RequestTimeoutError", "../errors/CancelError", "../_base/array", "../_base/window", "../has!host-browser?dom-addeventlistener?:../on:"], function(util, RequestTimeoutError, CancelError, array, win, on) {
                var _inFlightIntvl = null,
                    _inFlight = [];

                function watchInFlight() {
                    var now = +new Date;
                    for (var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++) {
                        var response = dfd.response,
                            options = response.options;
                        if (dfd.isCanceled && dfd.isCanceled() || dfd.isValid && !dfd.isValid(response)) {
                            _inFlight.splice(i--, 1);
                            watch._onAction && watch._onAction()
                        } else if (dfd.isReady && dfd.isReady(response)) {
                            _inFlight.splice(i--, 1);
                            dfd.handleResponse(response);
                            watch._onAction && watch._onAction()
                        } else if (dfd.startTime) {
                            if (dfd.startTime + (options.timeout || 0) < now) {
                                _inFlight.splice(i--, 1);
                                dfd.cancel(new RequestTimeoutError("Timeout exceeded", response));
                                watch._onAction && watch._onAction()
                            }
                        }
                    }
                    watch._onInFlight && watch._onInFlight(dfd);
                    if (!_inFlight.length) {
                        clearInterval(_inFlightIntvl);
                        _inFlightIntvl = null
                    }
                }

                function watch(dfd) {
                    if (dfd.response.options.timeout) {
                        dfd.startTime = +new Date
                    }
                    if (dfd.isFulfilled()) {
                        return
                    }
                    _inFlight.push(dfd);
                    if (!_inFlightIntvl) {
                        _inFlightIntvl = setInterval(watchInFlight, 50)
                    }
                    if (dfd.response.options.sync) {
                        watchInFlight()
                    }
                }
                watch.cancelAll = function cancelAll() {
                    try {
                        array.forEach(_inFlight, function(dfd) {
                            try {
                                dfd.cancel(new CancelError("All requests canceled."))
                            } catch (e) {}
                        })
                    } catch (e) {}
                };
                if (win && on && win.doc.attachEvent) {
                    on(win.global, "unload", function() {
                        watch.cancelAll()
                    })
                }
                return watch
            })
        },
        "dojo/request/util": function() {
            define(["exports", "../errors/RequestError", "../errors/CancelError", "../Deferred", "../io-query", "../_base/array", "../_base/lang", "../promise/Promise"], function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise) {
                exports.deepCopy = function deepCopy(target, source) {
                    for (var name in source) {
                        var tval = target[name],
                            sval = source[name];
                        if (tval !== sval) {
                            if (tval && typeof tval === "object" && sval && typeof sval === "object") {
                                exports.deepCopy(tval, sval)
                            } else {
                                target[name] = sval
                            }
                        }
                    }
                    return target
                };
                exports.deepCreate = function deepCreate(source, properties) {
                    properties = properties || {};
                    var target = lang.delegate(source),
                        name, value;
                    for (name in source) {
                        value = source[name];
                        if (value && typeof value === "object") {
                            target[name] = exports.deepCreate(value, properties[name])
                        }
                    }
                    return exports.deepCopy(target, properties)
                };
                var freeze = Object.freeze || function(obj) {
                    return obj
                };

                function okHandler(response) {
                    return freeze(response)
                }

                function dataHandler(response) {
                    return response.data || response.text
                }
                exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last) {
                    var def = new Deferred(function(reason) {
                        cancel && cancel(def, response);
                        if (!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)) {
                            return new CancelError("Request canceled", response)
                        }
                        return reason
                    });
                    def.response = response;
                    def.isValid = isValid;
                    def.isReady = isReady;
                    def.handleResponse = handleResponse;

                    function errHandler(error) {
                        error.response = response;
                        throw error
                    }
                    var responsePromise = def.then(okHandler).otherwise(errHandler);
                    if (exports.notify) {
                        responsePromise.then(lang.hitch(exports.notify, "emit", "load"), lang.hitch(exports.notify, "emit", "error"))
                    }
                    var dataPromise = responsePromise.then(dataHandler);
                    var promise = new Promise;
                    for (var prop in dataPromise) {
                        if (dataPromise.hasOwnProperty(prop)) {
                            promise[prop] = dataPromise[prop]
                        }
                    }
                    promise.response = responsePromise;
                    freeze(promise);
                    if (last) {
                        def.then(function(response) {
                            last.call(def, response)
                        }, function(error) {
                            last.call(def, response, error)
                        })
                    }
                    def.promise = promise;
                    def.then = promise.then;
                    return def
                };
                exports.addCommonMethods = function addCommonMethods(provider, methods) {
                    array.forEach(methods || ["GET", "POST", "PUT", "DELETE"], function(method) {
                        provider[(method === "DELETE" ? "DEL" : method).toLowerCase()] = function(url, options) {
                            options = lang.delegate(options || {});
                            options.method = method;
                            return provider(url, options)
                        }
                    })
                };
                exports.parseArgs = function parseArgs(url, options, skipData) {
                    var data = options.data,
                        query = options.query;
                    if (data && !skipData) {
                        if (typeof data === "object") {
                            options.data = ioQuery.objectToQuery(data)
                        }
                    }
                    if (query) {
                        if (typeof query === "object") {
                            query = ioQuery.objectToQuery(query)
                        }
                        if (options.preventCache) {
                            query += (query ? "&" : "") + "request.preventCache=" + +new Date
                        }
                    } else if (options.preventCache) {
                        query = "request.preventCache=" + +new Date
                    }
                    if (url && query) {
                        url += (~url.indexOf("?") ? "&" : "?") + query
                    }
                    return {
                        url: url,
                        options: options,
                        getHeader: function(headerName) {
                            return null
                        }
                    }
                };
                exports.checkStatus = function(stat) {
                    stat = stat || 0;
                    return stat >= 200 && stat < 300 || stat === 304 || stat === 1223 || !stat
                }
            })
        },
        "dojo/errors/RequestError": function() {
            define(["./create"], function(create) {
                return create("RequestError", function(message, response) {
                    this.response = response
                })
            })
        },
        "dojo/errors/RequestTimeoutError": function() {
            define(["./create", "./RequestError"], function(create, RequestError) {
                return create("RequestTimeoutError", null, RequestError, {
                    dojoType: "timeout"
                })
            })
        },
        "dojo/request/xhr": function() {
            define(["../errors/RequestError", "./watch", "./handlers", "./util", "../has"], function(RequestError, watch, handlers, util, has) {
                has.add("native-xhr", function() {
                    return typeof XMLHttpRequest !== "undefined"
                });
                has.add("dojo-force-activex-xhr", function() {
                    return has("activex") && !document.addEventListener && window.location.protocol === "file:"
                });
                has.add("native-xhr2", function() {
                    if (!has("native-xhr")) {
                        return
                    }
                    var x = new XMLHttpRequest;
                    return typeof x["addEventListener"] !== "undefined" && (typeof opera === "undefined" || typeof x["upload"] !== "undefined")
                });
                has.add("native-formdata", function() {
                    return typeof FormData !== "undefined"
                });
                has.add("native-response-type", function() {
                    return has("native-xhr") && typeof(new XMLHttpRequest).responseType !== "undefined"
                });
                has.add("native-xhr2-blob", function() {
                    if (!has("native-response-type")) {
                        return
                    }
                    var x = new XMLHttpRequest;
                    x.open("GET", "/", true);
                    x.responseType = "blob";
                    var responseType = x.responseType;
                    x.abort();
                    return responseType === "blob"
                });
                var nativeResponseTypes = {
                    blob: has("native-xhr2-blob") ? "blob" : "arraybuffer",
                    document: "document",
                    arraybuffer: "arraybuffer"
                };

                function handleResponse(response, error) {
                    var _xhr = response.xhr;
                    response.status = response.xhr.status;
                    try {
                        response.text = _xhr.responseText
                    } catch (e) {}
                    if (response.options.handleAs === "xml") {
                        response.data = _xhr.responseXML
                    }
                    if (!error) {
                        try {
                            handlers(response)
                        } catch (e) {
                            error = e
                        }
                    }
                    if (error) {
                        this.reject(error)
                    } else if (util.checkStatus(_xhr.status)) {
                        this.resolve(response)
                    } else {
                        error = new RequestError("Unable to load " + response.url + " status: " + _xhr.status, response);
                        this.reject(error)
                    }
                }
                var isValid, isReady, addListeners, cancel;
                if (has("native-xhr2")) {
                    isValid = function(response) {
                        return !this.isFulfilled()
                    };
                    cancel = function(dfd, response) {
                        response.xhr.abort()
                    };
                    addListeners = function(_xhr, dfd, response) {
                        function onLoad(evt) {
                            dfd.handleResponse(response)
                        }

                        function onError(evt) {
                            var _xhr = evt.target;
                            var error = new RequestError("Unable to load " + response.url + " status: " + _xhr.status, response);
                            dfd.handleResponse(response, error)
                        }

                        function onProgress(evt) {
                            if (evt.lengthComputable) {
                                response.loaded = evt.loaded;
                                response.total = evt.total;
                                dfd.progress(response)
                            } else if (response.xhr.readyState === 3) {
                                response.loaded = evt.position;
                                dfd.progress(response)
                            }
                        }
                        _xhr.addEventListener("load", onLoad, false);
                        _xhr.addEventListener("error", onError, false);
                        _xhr.addEventListener("progress", onProgress, false);
                        return function() {
                            _xhr.removeEventListener("load", onLoad, false);
                            _xhr.removeEventListener("error", onError, false);
                            _xhr.removeEventListener("progress", onProgress, false);
                            _xhr = null
                        }
                    }
                } else {
                    isValid = function(response) {
                        return response.xhr.readyState
                    };
                    isReady = function(response) {
                        return 4 === response.xhr.readyState
                    };
                    cancel = function(dfd, response) {
                        var xhr = response.xhr;
                        var _at = typeof xhr.abort;
                        if (_at === "function" || _at === "object" || _at === "unknown") {
                            xhr.abort()
                        }
                    }
                }

                function getHeader(headerName) {
                    return this.xhr.getResponseHeader(headerName)
                }
                var undefined, defaultOptions = {
                    data: null,
                    query: null,
                    sync: false,
                    method: "GET"
                };

                function xhr(url, options, returnDeferred) {
                    var isFormData = has("native-formdata") && options && options.data && options.data instanceof FormData;
                    var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), isFormData);
                    url = response.url;
                    options = response.options;
                    var remover, last = function() {
                        remover && remover()
                    };
                    var dfd = util.deferred(response, cancel, isValid, isReady, handleResponse, last);
                    var _xhr = response.xhr = xhr._create();
                    if (!_xhr) {
                        dfd.cancel(new RequestError("XHR was not created"));
                        return returnDeferred ? dfd : dfd.promise
                    }
                    response.getHeader = getHeader;
                    if (addListeners) {
                        remover = addListeners(_xhr, dfd, response)
                    }
                    var data = options.data,
                        async = !options.sync,
                        method = options.method;
                    try {
                        _xhr.open(method, url, async, options.user || undefined, options.password || undefined);
                        if (options.withCredentials) {
                            _xhr.withCredentials = options.withCredentials
                        }
                        if (has("native-response-type") && options.handleAs in nativeResponseTypes) {
                            _xhr.responseType = nativeResponseTypes[options.handleAs]
                        }
                        var headers = options.headers,
                            contentType = isFormData ? false : "application/x-www-form-urlencoded";
                        if (headers) {
                            for (var hdr in headers) {
                                if (hdr.toLowerCase() === "content-type") {
                                    contentType = headers[hdr]
                                } else if (headers[hdr]) {
                                    _xhr.setRequestHeader(hdr, headers[hdr])
                                }
                            }
                        }
                        if (contentType && contentType !== false) {
                            _xhr.setRequestHeader("Content-Type", contentType)
                        }
                        if (!headers || !("X-Requested-With" in headers)) {
                            _xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest")
                        }
                        if (util.notify) {
                            util.notify.emit("send", response, dfd.promise.cancel)
                        }
                        _xhr.send(data)
                    } catch (e) {
                        dfd.reject(e)
                    }
                    watch(dfd);
                    _xhr = null;
                    return returnDeferred ? dfd : dfd.promise
                }
                xhr._create = function() {
                    throw new Error("XMLHTTP not available")
                };
                if (has("native-xhr") && !has("dojo-force-activex-xhr")) {
                    xhr._create = function() {
                        return new XMLHttpRequest
                    }
                } else if (has("activex")) {
                    try {
                        new ActiveXObject("Msxml2.XMLHTTP");
                        xhr._create = function() {
                            return new ActiveXObject("Msxml2.XMLHTTP")
                        }
                    } catch (e) {
                        try {
                            new ActiveXObject("Microsoft.XMLHTTP");
                            xhr._create = function() {
                                return new ActiveXObject("Microsoft.XMLHTTP")
                            }
                        } catch (e) {}
                    }
                }
                util.addCommonMethods(xhr);
                return xhr
            })
        },
        "dojo/request/handlers": function() {
            define(["../json", "../_base/kernel", "../_base/array", "../has", "../selector/_loader"], function(JSON, kernel, array, has) {
                has.add("activex", typeof ActiveXObject !== "undefined");
                has.add("dom-parser", function(global) {
                    return "DOMParser" in global
                });
                var handleXML;
                if (has("activex")) {
                    var dp = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML.DOMDocument"];
                    var lastParser;
                    handleXML = function(response) {
                        var result = response.data;
                        var text = response.text;
                        if (result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")) {
                            result = (new DOMParser).parseFromString(text, "application/xml")
                        }

                        function createDocument(p) {
                            try {
                                var dom = new ActiveXObject(p);
                                dom.async = false;
                                dom.loadXML(text);
                                result = dom;
                                lastParser = p
                            } catch (e) {
                                return false
                            }
                            return true
                        }
                        if (!result || !result.documentElement) {
                            if (!lastParser || !createDocument(lastParser)) {
                                array.some(dp, createDocument)
                            }
                        }
                        return result
                    }
                }
                var handleNativeResponse = function(response) {
                    if (!has("native-xhr2-blob") && response.options.handleAs === "blob" && typeof Blob !== "undefined") {
                        return new Blob([response.xhr.response], {
                            type: response.xhr.getResponseHeader("Content-Type")
                        })
                    }
                    return response.xhr.response
                };
                var handlers = {
                    javascript: function(response) {
                        return kernel.eval(response.text || "")
                    },
                    json: function(response) {
                        return JSON.parse(response.text || null)
                    },
                    xml: handleXML,
                    blob: handleNativeResponse,
                    arraybuffer: handleNativeResponse,
                    document: handleNativeResponse
                };

                function handle(response) {
                    var handler = handlers[response.options.handleAs];
                    response.data = handler ? handler(response) : response.data || response.text;
                    return response
                }
                handle.register = function(name, handler) {
                    handlers[name] = handler
                };
                return handle
            })
        },
        "dojo/_base/fx": function() {
            define(["./kernel", "./config", "./lang", "../Evented", "./Color", "../aspect", "../sniff", "../dom", "../dom-style"], function(dojo, config, lang, Evented, Color, aspect, has, dom, style) {
                var _mixin = lang.mixin;
                var basefx = {};
                var _Line = basefx._Line = function(start, end) {
                    this.start = start;
                    this.end = end
                };
                _Line.prototype.getValue = function(n) {
                    return (this.end - this.start) * n + this.start
                };
                var Animation = basefx.Animation = function(args) {
                    _mixin(this, args);
                    if (lang.isArray(this.curve)) {
                        this.curve = new _Line(this.curve[0], this.curve[1])
                    }
                };
                Animation.prototype = new Evented;
                lang.extend(Animation, {
                    duration: 350,
                    repeat: 0,
                    rate: 20,
                    _percent: 0,
                    _startRepeatCount: 0,
                    _getStep: function() {
                        var _p = this._percent,
                            _e = this.easing;
                        return _e ? _e(_p) : _p
                    },
                    _fire: function(evt, args) {
                        var a = args || [];
                        if (this[evt]) {
                            if (config.debugAtAllCosts) {
                                this[evt].apply(this, a)
                            } else {
                                try {
                                    this[evt].apply(this, a)
                                } catch (e) {
                                    console.error("exception in animation handler for:", evt);
                                    console.error(e)
                                }
                            }
                        }
                        return this
                    },
                    play: function(delay, gotoStart) {
                        var _t = this;
                        if (_t._delayTimer) {
                            _t._clearTimer()
                        }
                        if (gotoStart) {
                            _t._stopTimer();
                            _t._active = _t._paused = false;
                            _t._percent = 0
                        } else if (_t._active && !_t._paused) {
                            return _t
                        }
                        _t._fire("beforeBegin", [_t.node]);
                        var de = delay || _t.delay,
                            _p = lang.hitch(_t, "_play", gotoStart);
                        if (de > 0) {
                            _t._delayTimer = setTimeout(_p, de);
                            return _t
                        }
                        _p();
                        return _t
                    },
                    _play: function(gotoStart) {
                        var _t = this;
                        if (_t._delayTimer) {
                            _t._clearTimer()
                        }
                        _t._startTime = (new Date).valueOf();
                        if (_t._paused) {
                            _t._startTime -= _t.duration * _t._percent
                        }
                        _t._active = true;
                        _t._paused = false;
                        var value = _t.curve.getValue(_t._getStep());
                        if (!_t._percent) {
                            if (!_t._startRepeatCount) {
                                _t._startRepeatCount = _t.repeat
                            }
                            _t._fire("onBegin", [value])
                        }
                        _t._fire("onPlay", [value]);
                        _t._cycle();
                        return _t
                    },
                    pause: function() {
                        var _t = this;
                        if (_t._delayTimer) {
                            _t._clearTimer()
                        }
                        _t._stopTimer();
                        if (!_t._active) {
                            return _t
                        }
                        _t._paused = true;
                        _t._fire("onPause", [_t.curve.getValue(_t._getStep())]);
                        return _t
                    },
                    gotoPercent: function(percent, andPlay) {
                        var _t = this;
                        _t._stopTimer();
                        _t._active = _t._paused = true;
                        _t._percent = percent;
                        if (andPlay) {
                            _t.play()
                        }
                        return _t
                    },
                    stop: function(gotoEnd) {
                        var _t = this;
                        if (_t._delayTimer) {
                            _t._clearTimer()
                        }
                        if (!_t._timer) {
                            return _t
                        }
                        _t._stopTimer();
                        if (gotoEnd) {
                            _t._percent = 1
                        }
                        _t._fire("onStop", [_t.curve.getValue(_t._getStep())]);
                        _t._active = _t._paused = false;
                        return _t
                    },
                    destroy: function() {
                        this.stop()
                    },
                    status: function() {
                        if (this._active) {
                            return this._paused ? "paused" : "playing"
                        }
                        return "stopped"
                    },
                    _cycle: function() {
                        var _t = this;
                        if (_t._active) {
                            var curr = (new Date).valueOf();
                            var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / _t.duration;
                            if (step >= 1) {
                                step = 1
                            }
                            _t._percent = step;
                            if (_t.easing) {
                                step = _t.easing(step)
                            }
                            _t._fire("onAnimate", [_t.curve.getValue(step)]);
                            if (_t._percent < 1) {
                                _t._startTimer()
                            } else {
                                _t._active = false;
                                if (_t.repeat > 0) {
                                    _t.repeat--;
                                    _t.play(null, true)
                                } else if (_t.repeat == -1) {
                                    _t.play(null, true)
                                } else {
                                    if (_t._startRepeatCount) {
                                        _t.repeat = _t._startRepeatCount;
                                        _t._startRepeatCount = 0
                                    }
                                }
                                _t._percent = 0;
                                _t._fire("onEnd", [_t.node]);
                                !_t.repeat && _t._stopTimer()
                            }
                        }
                        return _t
                    },
                    _clearTimer: function() {
                        clearTimeout(this._delayTimer);
                        delete this._delayTimer
                    }
                });
                var ctr = 0,
                    timer = null,
                    runner = {
                        run: function() {}
                    };
                lang.extend(Animation, {
                    _startTimer: function() {
                        if (!this._timer) {
                            this._timer = aspect.after(runner, "run", lang.hitch(this, "_cycle"), true);
                            ctr++
                        }
                        if (!timer) {
                            timer = setInterval(lang.hitch(runner, "run"), this.rate)
                        }
                    },
                    _stopTimer: function() {
                        if (this._timer) {
                            this._timer.remove();
                            this._timer = null;
                            ctr--
                        }
                        if (ctr <= 0) {
                            clearInterval(timer);
                            timer = null;
                            ctr = 0
                        }
                    }
                });
                var _makeFadeable = has("ie") ? function(node) {
                    var ns = node.style;
                    if (!ns.width.length && style.get(node, "width") == "auto") {
                        ns.width = "auto"
                    }
                } : function() {};
                basefx._fade = function(args) {
                    args.node = dom.byId(args.node);
                    var fArgs = _mixin({
                            properties: {}
                        }, args),
                        props = fArgs.properties.opacity = {};
                    props.start = !("start" in fArgs) ? function() {
                        return +style.get(fArgs.node, "opacity") || 0
                    } : fArgs.start;
                    props.end = fArgs.end;
                    var anim = basefx.animateProperty(fArgs);
                    aspect.after(anim, "beforeBegin", lang.partial(_makeFadeable, fArgs.node), true);
                    return anim
                };
                basefx.fadeIn = function(args) {
                    return basefx._fade(_mixin({
                        end: 1
                    }, args))
                };
                basefx.fadeOut = function(args) {
                    return basefx._fade(_mixin({
                        end: 0
                    }, args))
                };
                basefx._defaultEasing = function(n) {
                    return .5 + Math.sin((n + 1.5) * Math.PI) / 2
                };
                var PropLine = function(properties) {
                    this._properties = properties;
                    for (var p in properties) {
                        var prop = properties[p];
                        if (prop.start instanceof Color) {
                            prop.tempColor = new Color
                        }
                    }
                };
                PropLine.prototype.getValue = function(r) {
                    var ret = {};
                    for (var p in this._properties) {
                        var prop = this._properties[p],
                            start = prop.start;
                        if (start instanceof Color) {
                            ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss()
                        } else if (!lang.isArray(start)) {
                            ret[p] = (prop.end - start) * r + start + (p != "opacity" ? prop.units || "px" : 0)
                        }
                    }
                    return ret
                };
                basefx.animateProperty = function(args) {
                    var n = args.node = dom.byId(args.node);
                    if (!args.easing) {
                        args.easing = dojo._defaultEasing
                    }
                    var anim = new Animation(args);
                    aspect.after(anim, "beforeBegin", lang.hitch(anim, function() {
                        var pm = {};
                        for (var p in this.properties) {
                            if (p == "width" || p == "height") {
                                this.node.display = "block"
                            }
                            var prop = this.properties[p];
                            if (lang.isFunction(prop)) {
                                prop = prop(n)
                            }
                            prop = pm[p] = _mixin({}, lang.isObject(prop) ? prop : {
                                end: prop
                            });
                            if (lang.isFunction(prop.start)) {
                                prop.start = prop.start(n)
                            }
                            if (lang.isFunction(prop.end)) {
                                prop.end = prop.end(n)
                            }
                            var isColor = p.toLowerCase().indexOf("color") >= 0;

                            function getStyle(node, p) {
                                var v = {
                                    height: node.offsetHeight,
                                    width: node.offsetWidth
                                }[p];
                                if (v !== undefined) {
                                    return v
                                }
                                v = style.get(node, p);
                                return p == "opacity" ? +v : isColor ? v : parseFloat(v)
                            }
                            if (!("end" in prop)) {
                                prop.end = getStyle(n, p)
                            } else if (!("start" in prop)) {
                                prop.start = getStyle(n, p)
                            }
                            if (isColor) {
                                prop.start = new Color(prop.start);
                                prop.end = new Color(prop.end)
                            } else {
                                prop.start = p == "opacity" ? +prop.start : parseFloat(prop.start)
                            }
                        }
                        this.curve = new PropLine(pm)
                    }), true);
                    aspect.after(anim, "onAnimate", lang.hitch(style, "set", anim.node), true);
                    return anim
                };
                basefx.anim = function(node, properties, duration, easing, onEnd, delay) {
                    return basefx.animateProperty({
                        node: node,
                        duration: duration || Animation.prototype.duration,
                        properties: properties,
                        easing: easing,
                        onEnd: onEnd
                    }).play(delay || 0)
                };
                if (1) {
                    _mixin(dojo, basefx);
                    dojo._Animation = Animation
                }
                return basefx
            })
        },
        "dojo/_base/loader": function() {
            define(["./kernel", "../has", "require", "module", "../json", "./lang", "./array"], function(dojo, has, require, thisModule, json, lang, array) {
                if (!1) {
                    console.error("cannot load the Dojo v1.x loader with a foreign loader");
                    return 0
                }
                1 || has.add("dojo-fast-sync-require", 1);
                var makeErrorToken = function(id) {
                        return {
                            src: thisModule.id,
                            id: id
                        }
                    },
                    slashName = function(name) {
                        return name.replace(/\./g, "/")
                    },
                    buildDetectRe = /\/\/>>built/,
                    dojoRequireCallbacks = [],
                    dojoRequireModuleStack = [],
                    dojoRequirePlugin = function(mid, require, loaded) {
                        dojoRequireCallbacks.push(loaded);
                        array.forEach(mid.split(","), function(mid) {
                            var module = getModule(mid, require.module);
                            dojoRequireModuleStack.push(module);
                            injectModule(module)
                        });
                        checkDojoRequirePlugin()
                    },
                    checkDojoRequirePlugin = 1 ? function() {
                        var module, mid;
                        for (mid in modules) {
                            module = modules[mid];
                            if (module.noReqPluginCheck === undefined) {
                                module.noReqPluginCheck = /loadInit\!/.test(mid) || /require\!/.test(mid) ? 1 : 0
                            }
                            if (!module.executed && !module.noReqPluginCheck && module.injected == requested) {
                                return
                            }
                        }
                        guardCheckComplete(function() {
                            var oldCallbacks = dojoRequireCallbacks;
                            dojoRequireCallbacks = [];
                            array.forEach(oldCallbacks, function(cb) {
                                cb(1)
                            })
                        })
                    } : function() {
                        var touched, traverse = function(m) {
                            touched[m.mid] = 1;
                            for (var t, module, deps = m.deps || [], i = 0; i < deps.length; i++) {
                                module = deps[i];
                                if (!(t = touched[module.mid])) {
                                    if (t === 0 || !traverse(module)) {
                                        touched[m.mid] = 0;
                                        return false
                                    }
                                }
                            }
                            return true
                        };
                        return function() {
                            var module, mid;
                            touched = {};
                            for (mid in modules) {
                                module = modules[mid];
                                if (module.executed || module.noReqPluginCheck) {
                                    touched[mid] = 1
                                } else {
                                    if (module.noReqPluginCheck !== 0) {
                                        module.noReqPluginCheck = /loadInit\!/.test(mid) || /require\!/.test(mid) ? 1 : 0
                                    }
                                    if (module.noReqPluginCheck) {
                                        touched[mid] = 1
                                    } else if (module.injected !== arrived) {
                                        touched[mid] = 0
                                    }
                                }
                            }
                            for (var t, i = 0, end = dojoRequireModuleStack.length; i < end; i++) {
                                module = dojoRequireModuleStack[i];
                                if (!(t = touched[module.mid])) {
                                    if (t === 0 || !traverse(module)) {
                                        return
                                    }
                                }
                            }
                            guardCheckComplete(function() {
                                var oldCallbacks = dojoRequireCallbacks;
                                dojoRequireCallbacks = [];
                                array.forEach(oldCallbacks, function(cb) {
                                    cb(1)
                                })
                            })
                        }
                    }(),
                    dojoLoadInitPlugin = function(mid, require, loaded) {
                        require([mid], function(bundle) {
                            require(bundle.names, function() {
                                for (var scopeText = "", args = [], i = 0; i < arguments.length; i++) {
                                    scopeText += "var " + bundle.names[i] + "= arguments[" + i + "]; ";
                                    args.push(arguments[i])
                                }
                                eval(scopeText);
                                var callingModule = require.module,
                                    requireList = [],
                                    i18nDeps, syncLoaderApi = {
                                        provide: function(moduleName) {
                                            moduleName = slashName(moduleName);
                                            var providedModule = getModule(moduleName, callingModule);
                                            if (providedModule !== callingModule) {
                                                setArrived(providedModule)
                                            }
                                        },
                                        require: function(moduleName, omitModuleCheck) {
                                            moduleName = slashName(moduleName);
                                            omitModuleCheck && (getModule(moduleName, callingModule).result = nonmodule);
                                            requireList.push(moduleName)
                                        },
                                        requireLocalization: function(moduleName, bundleName, locale) {
                                            if (!i18nDeps) {
                                                i18nDeps = ["dojo/i18n"]
                                            }
                                            locale = (locale || dojo.locale).toLowerCase();
                                            moduleName = slashName(moduleName) + "/nls/" + (/root/i.test(locale) ? "" : locale + "/") + slashName(bundleName);
                                            if (getModule(moduleName, callingModule).isXd) {
                                                i18nDeps.push("dojo/i18n!" + moduleName)
                                            }
                                        },
                                        loadInit: function(f) {
                                            f()
                                        }
                                    },
                                    hold = {},
                                    p;
                                try {
                                    for (p in syncLoaderApi) {
                                        hold[p] = dojo[p];
                                        dojo[p] = syncLoaderApi[p]
                                    }
                                    bundle.def.apply(null, args)
                                } catch (e) {
                                    signal("error", [makeErrorToken("failedDojoLoadInit"), e])
                                } finally {
                                    for (p in syncLoaderApi) {
                                        dojo[p] = hold[p]
                                    }
                                }
                                if (i18nDeps) {
                                    requireList = requireList.concat(i18nDeps)
                                }
                                if (requireList.length) {
                                    dojoRequirePlugin(requireList.join(","), require, loaded)
                                } else {
                                    loaded()
                                }
                            })
                        })
                    },
                    extractApplication = function(text, startSearch, startApplication) {
                        var parenRe = /\(|\)/g,
                            matchCount = 1,
                            match;
                        parenRe.lastIndex = startSearch;
                        while (match = parenRe.exec(text)) {
                            if (match[0] == ")") {
                                matchCount -= 1
                            } else {
                                matchCount += 1
                            }
                            if (matchCount == 0) {
                                break
                            }
                        }
                        if (matchCount != 0) {
                            throw "unmatched paren around character " + parenRe.lastIndex + " in: " + text
                        }
                        return [dojo.trim(text.substring(startApplication, parenRe.lastIndex)) + ";\n", parenRe.lastIndex]
                    },
                    removeCommentRe = /(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/gm,
                    syncLoaderApiRe = /(^|\s)dojo\.(loadInit|require|provide|requireLocalization|requireIf|requireAfterIf|platformRequire)\s*\(/gm,
                    amdLoaderApiRe = /(^|\s)(require|define)\s*\(/m,
                    extractLegacyApiApplications = function(text, noCommentText) {
                        var match, startSearch, startApplication, application, loadInitApplications = [],
                            otherApplications = [],
                            allApplications = [];
                        noCommentText = noCommentText || text.replace(removeCommentRe, function(match) {
                            syncLoaderApiRe.lastIndex = amdLoaderApiRe.lastIndex = 0;
                            return syncLoaderApiRe.test(match) || amdLoaderApiRe.test(match) ? "" : match
                        });
                        while (match = syncLoaderApiRe.exec(noCommentText)) {
                            startSearch = syncLoaderApiRe.lastIndex;
                            startApplication = startSearch - match[0].length;
                            application = extractApplication(noCommentText, startSearch, startApplication);
                            if (match[2] == "loadInit") {
                                loadInitApplications.push(application[0])
                            } else {
                                otherApplications.push(application[0])
                            }
                            syncLoaderApiRe.lastIndex = application[1]
                        }
                        allApplications = loadInitApplications.concat(otherApplications);
                        if (allApplications.length || !amdLoaderApiRe.test(noCommentText)) {
                            return [text.replace(/(^|\s)dojo\.loadInit\s*\(/g, "\n0 && dojo.loadInit("), allApplications.join(""), allApplications]
                        } else {
                            return 0
                        }
                    },
                    transformToAmd = function(module, text) {
                        var extractResult, id, names = [],
                            namesAsStrings = [];
                        if (buildDetectRe.test(text) || !(extractResult = extractLegacyApiApplications(text))) {
                            return 0
                        }
                        id = module.mid + "-*loadInit";
                        for (var p in getModule("dojo", module).result.scopeMap) {
                            names.push(p);
                            namesAsStrings.push('"' + p + '"')
                        }
                        return "// xdomain rewrite of " + module.mid + "\n" + "define('" + id + "',{\n" + "	names:" + json.stringify(names) + ",\n" + "	def:function(" + names.join(",") + "){" + extractResult[1] + "}" + "});\n\n" + "define(" + json.stringify(names.concat(["dojo/loadInit!" + id])) + ", function(" + names.join(",") + "){\n" + extractResult[0] + "});"
                    },
                    loaderVars = require.initSyncLoader(dojoRequirePlugin, checkDojoRequirePlugin, transformToAmd),
                    sync = loaderVars.sync,
                    requested = loaderVars.requested,
                    arrived = loaderVars.arrived,
                    nonmodule = loaderVars.nonmodule,
                    executing = loaderVars.executing,
                    executed = loaderVars.executed,
                    syncExecStack = loaderVars.syncExecStack,
                    modules = loaderVars.modules,
                    execQ = loaderVars.execQ,
                    getModule = loaderVars.getModule,
                    injectModule = loaderVars.injectModule,
                    setArrived = loaderVars.setArrived,
                    signal = loaderVars.signal,
                    finishExec = loaderVars.finishExec,
                    execModule = loaderVars.execModule,
                    getLegacyMode = loaderVars.getLegacyMode,
                    guardCheckComplete = loaderVars.guardCheckComplete;
                dojoRequirePlugin = loaderVars.dojoRequirePlugin;
                dojo.provide = function(mid) {
                    var executingModule = syncExecStack[0],
                        module = lang.mixin(getModule(slashName(mid), require.module), {
                            executed: executing,
                            result: lang.getObject(mid, true)
                        });
                    setArrived(module);
                    if (executingModule) {
                        (executingModule.provides || (executingModule.provides = [])).push(function() {
                            module.result = lang.getObject(mid);
                            delete module.provides;
                            module.executed !== executed && finishExec(module)
                        })
                    }
                    return module.result
                };
                has.add("config-publishRequireResult", 1, 0, 0);
                dojo.require = function(moduleName, omitModuleCheck) {
                    function doRequire(mid, omitModuleCheck) {
                        var module = getModule(slashName(mid), require.module);
                        if (syncExecStack.length && syncExecStack[0].finish) {
                            syncExecStack[0].finish.push(mid);
                            return undefined
                        }
                        if (module.executed) {
                            return module.result
                        }
                        omitModuleCheck && (module.result = nonmodule);
                        var currentMode = getLegacyMode();
                        injectModule(module);
                        currentMode = getLegacyMode();
                        if (module.executed !== executed && module.injected === arrived) {
                            loaderVars.guardCheckComplete(function() {
                                execModule(module)
                            })
                        }
                        if (module.executed) {
                            return module.result
                        }
                        if (currentMode == sync) {
                            if (module.cjs) {
                                execQ.unshift(module)
                            } else {
                                syncExecStack.length && (syncExecStack[0].finish = [mid])
                            }
                        } else {
                            execQ.push(module)
                        }
                        return undefined
                    }
                    var result = doRequire(moduleName, omitModuleCheck);
                    if (has("config-publishRequireResult") && !lang.exists(moduleName) && result !== undefined) {
                        lang.setObject(moduleName, result)
                    }
                    return result
                };
                dojo.loadInit = function(f) {
                    f()
                };
                dojo.registerModulePath = function(moduleName, prefix) {
                    var paths = {};
                    paths[moduleName.replace(/\./g, "/")] = prefix;
                    require({
                        paths: paths
                    })
                };
                dojo.platformRequire = function(modMap) {
                    var result = (modMap.common || []).concat(modMap[dojo._name] || modMap["default"] || []),
                        temp;
                    while (result.length) {
                        if (lang.isArray(temp = result.shift())) {
                            dojo.require.apply(dojo, temp)
                        } else {
                            dojo.require(temp)
                        }
                    }
                };
                dojo.requireIf = dojo.requireAfterIf = function(condition, moduleName, omitModuleCheck) {
                    if (condition) {
                        dojo.require(moduleName, omitModuleCheck)
                    }
                };
                dojo.requireLocalization = function(moduleName, bundleName, locale) {
                    require(["../i18n"], function(i18n) {
                        i18n.getLocalization(moduleName, bundleName, locale)
                    })
                };
                return {
                    extractLegacyApiApplications: extractLegacyApiApplications,
                    require: dojoRequirePlugin,
                    loadInit: dojoLoadInitPlugin
                }
            })
        }
    }
});
require({
    cache: {
        select: function() {
            define([], 1)
        },
        "ion/select": function() {
            require(["dojo/query", "dojo/on", "dojo/_base/event", "dojo/_base/array", "dojo/cookie", "dojo/dom-attr", "dojo/dom-class", "dojo/has", "dojo/dom", "dojo/domReady!"], function(query, on, event, array, cookie, domAttr, domClass, has, dom) {
                var players = dojo.query(".player");
                var activePlayerType = cookie("player");
                if (!activePlayerType) activePlayerType = "santa";
                cookie("player", activePlayerType, {
                    path: "/"
                });
                var activePlayerNode;
                array.forEach(players, function(player) {
                    var playerType = domAttr.get(player, "data-player");
                    domClass.toggle(player, "active", playerType == activePlayerType);
                    if (playerType == activePlayerType) activePlayerNode = player;
                    on(player, "click", function(e) {
                        event.stop(e);
                        var playerType = domAttr.get(this, "data-player");
                        domClass.remove(activePlayerNode, "active");
                        domClass.add(this, "active");
                        activePlayerType = playerType;
                        activePlayerNode = this;
                        cookie("player", activePlayerType, {
                            path: "/"
                        })
                    })
                });
                var hasTouch = has("touch");
                var hasGyro = false;
                var inputs = dojo.query(".input");
                var activeInputType = cookie("input");
                if (!activeInputType) activeInputType = hasTouch ? "touch" : "keyboard";
                cookie("input", activeInputType, {
                    path: "/"
                });
                var activeInputNode;
                array.forEach(inputs, function(input) {
                    var inputType = domAttr.get(input, "data-input");
                    if (inputType == "touch") {
                        if (!hasTouch) domClass.add(input, "disabled")
                    }
                    if (inputType == "gyro") {
                        if (!hasGyro) domClass.add(input, "disabled")
                    }
                    if (domClass.contains(input, "disabled")) return;
                    domClass.toggle(input, "active", inputType == activeInputType);
                    if (inputType == activeInputType) activeInputNode = input;
                    on(input, "click", function(e) {
                        event.stop(e);
                        var inputType = domAttr.get(this, "data-input");
                        domClass.remove(activeInputNode, "active");
                        domClass.add(this, "active");
                        activeInputType = inputType;
                        activeInputNode = this;
                        cookie("input", activeInputType, {
                            path: "/"
                        })
                    })
                });
                var choose = dom.byId("choose-skier"),
                    intro = dom.byId("description"),
                    about = dom.byId("about");
                domClass.remove(intro, "hidden");
                domClass.add(menu, "hidden");
                on(choose, "click", function() {
                    domClass.add(intro, "hidden");
                    domClass.remove(menu, "hidden")
                });
                on(about, "click", function() {
                    domClass.remove(intro, "hidden");
                    domClass.add(menu, "hidden")
                })
            })
        },
        "dojo/cookie": function() {
            define(["./_base/kernel", "./regexp"], function(dojo, regexp) {
                dojo.cookie = function(name, value, props) {
                    var c = document.cookie,
                        ret;
                    if (arguments.length == 1) {
                        var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
                        ret = matches ? decodeURIComponent(matches[1]) : undefined
                    } else {
                        props = props || {};
                        var exp = props.expires;
                        if (typeof exp == "number") {
                            var d = new Date;
                            d.setTime(d.getTime() + exp * 24 * 60 * 60 * 1e3);
                            exp = props.expires = d
                        }
                        if (exp && exp.toUTCString) {
                            props.expires = exp.toUTCString()
                        }
                        value = encodeURIComponent(value);
                        var updatedCookie = name + "=" + value,
                            propName;
                        for (propName in props) {
                            updatedCookie += "; " + propName;
                            var propValue = props[propName];
                            if (propValue !== true) {
                                updatedCookie += "=" + propValue
                            }
                        }
                        document.cookie = updatedCookie
                    }
                    return ret
                };
                dojo.cookie.isSupported = function() {
                    if (!("cookieEnabled" in navigator)) {
                        this("__djCookieTest__", "CookiesAllowed");
                        navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
                        if (navigator.cookieEnabled) {
                            this("__djCookieTest__", "", {
                                expires: -1
                            })
                        }
                    }
                    return navigator.cookieEnabled
                };
                return dojo.cookie
            })
        },
        "dojo/regexp": function() {
            define(["./_base/kernel", "./_base/lang"], function(dojo, lang) {
                var regexp = {};
                lang.setObject("dojo.regexp", regexp);
                regexp.escapeString = function(str, except) {
                    return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, function(ch) {
                        if (except && except.indexOf(ch) != -1) {
                            return ch
                        }
                        return "\\" + ch
                    })
                };
                regexp.buildGroupRE = function(arr, re, nonCapture) {
                    if (!(arr instanceof Array)) {
                        return re(arr)
                    }
                    var b = [];
                    for (var i = 0; i < arr.length; i++) {
                        b.push(re(arr[i]))
                    }
                    return regexp.group(b.join("|"), nonCapture)
                };
                regexp.group = function(expression, nonCapture) {
                    return "(" + (nonCapture ? "?:" : "") + expression + ")"
                };
                return regexp
            })
        }
    }
});
(function() {
    var require = this.require;
    require({
        cache: {}
    });
    !require.async && require(["dojo"]);
    require.boot && require.apply(null, require.boot)
})();